{"version":3,"sources":["../../src/driver.ts","../../src/Bls12381G2KeyPair.ts","../../bls12381/node_modules/@mattrglobal/bls12381-key-pair/node_modules/@mattrglobal/bbs-signatures/lib sync","../../bls12381/node_modules/@mattrglobal/bbs-signatures/lib sync","../../src/Cipher/crypto.ts","../../src/Cipher/algorithms/ecdhkdf.ts","../../src/Cipher/algorithms/classes/KeyEncryptionKey.ts","../../src/Cipher/algorithms/xc20p.ts","../../src/Cipher/DecryptTransformer.ts","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/Cipher/EncryptTransformer.ts","../../src/Cipher/getEpkGenerator.ts","serviceWorker.js","store/history.js","store/universal-wallet/actions.js","store/universal-wallet/reducer.js","store/universal-wallet/redux.js","store/universal-wallet/index.js","store/universal-wallet/container.js","store/index.js","components/Theme/Theme.js","pages/base/menu.js","pages/base/drawer.js","pages/base/base.js","pages/home/util.js","pages/home/Home.js","pages/index.js","pages/home/index.js","components/ParticlesContainer/ParticlesContainer.js","pages/errors/404.js","store/create.js","index.js","../../src/constants/index.ts","../../src/crypto.ts","../../src/functions/jwkToBase58.ts","../../src/functions/fingerprintToDid.ts","../../src/functions/fromJwk.ts","../../src/functions/getMultibaseFromJwk.ts","../../src/functions/base58KeyPairToJwk.ts","../../src/functions/getJwkTypeFromMultibase.ts","../../src/functions/toJwkPair.ts","../../src/KeyPair.ts","../../src/Jws/Jws.ts","../../src/Jwe/Jwe.ts","../../src/functions/generate.ts","../../src/keyUtils.ts","../../src/X25519KeyPair.ts","../../bls12381/dist/index.js","../../bls12381/node_modules/@mattrglobal/bls12381-key-pair/node_modules/@mattrglobal/node-bbs-signatures/lib sync","../../src/EdDSA.ts","../../src/Ed25519KeyPair.ts","../../src/Secp256k1KeyPair.ts","../../src/ES256K.ts","../node_modules/jspdf/dist sync","store/universal-wallet/handlers.js","assets/logo.svg"],"names":["keyToDidDoc","bls12381Key","did","fingerprint","keyId","id","publicKey","type","controller","publicKeyBase58","bs58","encode","publicKeyBuffer","authentication","assertionMethod","capabilityDelegation","capabilityInvocation","url","TypeError","split","pop","Bls12381G2KeyPair","fromFingerprint","generate","options","keyPair","generateBls12381KeyPair","from","privateKeyBase58","secretKey","toKeyPair","key","fingerprintFromPublicKey","kp","privateKeyBuffer","mattr","webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","process","crypto","window","deriveKey","secret","producerInfo","consumerInfo","input","Uint8Array","ALGORITHM_ID","offset","dv","DataView","Buffer","HASH_ALGORITHM","name","KEY_LENGTH","KeyEncryptionKey","this","wrapKey","unwrappedKey","wrappedKey","aeskw","bs64","unwrapKey","_wrappedKey","console","keyData","ciphertext","iv","tag","additionalData","cek","cipher","encrypted","data","Symbol","iterator","asyncIterator","getEpkGenerator","KeyPair","k0","keypair","epk","publicKeyJwk","Boolean","location","hostname","match","createBrowserHistory","setUniversalWalletProp","createAction","payload","handleActions","state","status","contents","vaultEndpoint","isSyncEnabled","isSyncing","connect","wallet","actions","reducer","container","compose","withRedux","withHandlers","router","connectRouter","history","font1","font2","font3","Theme","children","props","theme","createMuiTheme","splashImage","palette","primary","light","lighten","main","dark","darken","secondary","typography","useNextVariants","fontSize","fontFamily","join","h1","fontWeight","h2","h3","h4","textTransform","letterSpacing","h5","h6","subtitle1","subtitle2","body1","body2","button","caption","overline","overrides","MuiInput","MuiInputLabel","root","MuiAppBar","MuiButton","contained","boxShadow","Component","StyledMenu","withStyles","paper","border","elevation","getContentAnchorEl","anchorOrigin","vertical","horizontal","transformOrigin","StyledMenuItem","backgroundColor","color","common","white","MenuItem","CustomizedMenus","React","useState","anchorEl","setAnchorEl","IconButton","aria-controls","aria-haspopup","onClick","event","currentTarget","keepMounted","open","onClose","push","ListItemIcon","ListItemText","DrawerContent","List","ListItem","useStyles","makeStyles","display","width","appBar","zIndex","drawer","transition","transitions","create","easing","sharp","duration","leavingScreen","appBarShift","marginLeft","enteringScreen","menuButton","marginRight","hide","flexShrink","whiteSpace","drawerOpen","drawerClose","overflowX","spacing","breakpoints","up","toolbar","alignItems","justifyContent","padding","mixins","content","flexGrow","MiniDrawer","classes","useTheme","setOpen","className","CssBaseline","AppBar","position","clsx","Toolbar","aria-label","edge","src","logo","alt","title","style","height","Drawer","variant","direction","Divider","generateX25519","a","x25519","secureRandom","randomBytes","x25519KeyPair","didDocument","generateEd25519","ed25519","ed25519Key","fromEdKeyPair","generateSecp256k1","secp256k1","secp256k1Key","generateBls12381","bls12381","bls12381G2Key","generateP256","didKeyWebCrypto","kty","crvOrSize","toJsonWebKey","get","generateP384","generateP521","Home","setState","util","useEffect","Grid","item","sm","xs","Button","Typography","gutterBottom","value","JSON","stringify","routes","path","exact","component","ParticlesContainer","params","particles","line_linked","shadow","enable","blur","Fragment","top","NotFound","pathname","href","appReducers","persistConfig","whitelist","storage","middlewares","thunk","routerMiddleware","store","createStore","persistReducer","combineReducers","rootReducer","composeWithDevTools","applyMiddleware","withReduxEnhancer","persistor","persistStore","ReactDOM","render","map","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","log","SUPPORTED_EC","crvToMulticodecPrefix","multicodecToJwkType","0","crv","crvToJwsHashAlg","jwkToBase58","jwk","base64url","fingerprintToDid","methodName","fromJwk","publicKeyBytes","prefix","buffer","getMultibaseFromJwk","base58KeyPairToJwk","x","y","getJwkTypeFromMultibase","toJwkPair","_keypair","staticImplements","args","KeyPair_1","generateEphemeralKeyPair","epkArgs","kekFromEphemeralPeer","keyAgreementKey","ephemeralPublicKey","kek","kekFromStaticPeer","ephemeralKeyPair","staticPublicKey","epkPair","apu","apv","exportPrivateKey","signer","privateKeyJwk","namedCurve","privateKey","sign","hash","privateKeyToSigner","verifier","verify","publicKeyToVerifier","deriveSecret","public","result","d","keyAgreement","getKid","copy","digest","canonicalize","privateKeyJwkFromPrivateKeyBase58","privateKeyBytes","_jwk","kid","publicKeyJwkFromPublicKeyBase58","privateKeyBase58FromPrivateKeyJwk","publicKeyBase58FromPublicKeyJwk","X25519KeyPair","keyUtils","pubkeyBytes","isAvailable","X25519KeyPair_1","ed25519KeyPair","convertPublicKeyToX25519","convertSecretKeyToX25519","verifyFingerprint","error","valid","fingerprintBuffer","_private","toJwk","remotePubkeyBytes","x25519Key","require","publicKeyBase58FromPublicKeyHex","privateKeyBase58FromPrivateKeyHex","privateKeyBuf","publicKeyHexFromPublicKeyBase58","privateKeyHexFromPrivateKeyBase58","Ed25519KeyPair","addEncodedPublicKey","publicKeyNode","publicNode","toX25519KeyPair","signatureUInt8Array","signature","verified","privateKeyJwkFromPrivateKeyHex","keyto","publicKeyJwkFromPublicKeyHex","publicKeyHex","keyBin","privateKeyHexFromJwk","publicKeyHexFromJwk","uncompressedPublicKey","compressed","privateKeyUInt8ArrayFromJwk","privateKeyHex","publicKeyUInt8ArrayFromJwk","privateKeyUInt8ArrayFromPrivateKeyBase58","publicKeyUInt8ArrayFromPublicKeyBase58","privateKeyPem","publicKeyPem","_generate","Secp256k1KeyPair","messageHashUInt8Array","privateKeyUInt8Array","publicKeyUInt8Array","exportPrivate","getClient","_wallet","UniversalWallet2020","entropy","find","c","VaultClient","fromDerivedContents","client","isContentPersisted","localContents","undefined","generateWallet","_seed","toggleLockStatus","password","unlock","lock","deleteWallet","importWallet","encryptedWallet","import","exportWallet","export","saveWallet","issueCredential","credential","issue","verifiableCredential","proveVerifiableCredential","prove","verifiablePresentation","syncVault","getWalletContents","message","parse","tableData","EdvClient","generateId","schema","doc","addWalletContent"],"mappings":"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","file":"static/js/main.972146b6.chunk.js","sourcesContent":["import { Secp256k1KeyPair } from './Secp256k1KeyPair';\nexport const computeKeyId = async ({ key }: any) => {\n  return `did:key:${key.fingerprint()}#${key.fingerprint()}`;\n};\n\nexport const keyToDidDoc = (secp256k1Key: any) => {\n  const did = `did:key:${secp256k1Key.fingerprint()}`;\n  const keyId = `#${secp256k1Key.fingerprint()}`;\n  return {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      {\n        '@base': did,\n      },\n    ],\n    id: did,\n    publicKey: [\n      {\n        id: keyId,\n        type: secp256k1Key.type,\n        controller: did,\n        publicKeyBase58: secp256k1Key.publicKeyBase58,\n      },\n    ],\n    authentication: [keyId],\n    assertionMethod: [keyId],\n    capabilityDelegation: [keyId],\n    capabilityInvocation: [keyId],\n  };\n};\n\nexport const get = async ({ did, url }: any = {}) => {\n  did = did || url;\n  if (!did) {\n    throw new TypeError('\"did\" must be a string.');\n  }\n  const fingerprint = did\n    .split('#')[0]\n    .split('did:key:')\n    .pop();\n  const publicKey = await Secp256k1KeyPair.fromFingerprint({ fingerprint });\n  const didDoc = keyToDidDoc(publicKey);\n  return didDoc;\n};\n","import * as mattr from '@mattrglobal/bls12381-key-pair';\n\nimport { generateBls12381KeyPair } from '@mattrglobal/bbs-signatures';\nimport * as bs58 from 'bs58';\n\nexport class Bls12381G2KeyPair extends mattr.Bls12381G2KeyPair {\n  static async generate(options?: any) {\n    const keyPair = generateBls12381KeyPair();\n    return Bls12381G2KeyPair.from({\n      ...options,\n      privateKeyBase58: bs58.encode(keyPair.secretKey as Uint8Array),\n      publicKeyBase58: bs58.encode(keyPair.publicKey),\n    });\n  }\n\n  static toKeyPair(key: any) {\n    const fingerprint = Bls12381G2KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58: bs58.encode(key.publicKeyBuffer),\n    });\n    let kp: any = {\n      id: '#' + fingerprint,\n      type: 'Bls12381G2Key2020',\n      controller: `did:key:${fingerprint}`,\n      publicKeyBase58: bs58.encode(key.publicKeyBuffer),\n    };\n\n    if (key.privateKeyBuffer) {\n      kp.privateKeyBase58 = bs58.encode(key.privateKeyBuffer);\n    }\n    return kp;\n  }\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 1360;","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 1370;","import { Crypto } from 'node-webcrypto-ossl';\n\nfunction isNodejs() {\n  return (\n    typeof process === 'object' &&\n    typeof process.versions === 'object' &&\n    typeof process.versions.node !== 'undefined'\n  );\n}\n\nlet crypto: Crypto;\n\nif (isNodejs()) {\n  crypto = new Crypto();\n} else {\n  crypto = window.crypto as Crypto;\n}\n\nexport default crypto;\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport crypto from '../crypto';\n\n// only supported algorithm\nconst KEY_ALGORITHM = 'ECDH-ES+A256KW';\n\n// create static ALGORITHM_ID\nconst ALGORITHM_CONTENT = KEY_ALGORITHM; //new TextEncoder().encode();\nconst ALGORITHM_ID = new Uint8Array(4 + ALGORITHM_CONTENT.length);\n// write length of content as 32-bit big endian integer, then write content\nconst dv = new DataView(\n  ALGORITHM_ID.buffer,\n  ALGORITHM_ID.byteOffset,\n  ALGORITHM_ID.byteLength\n);\ndv.setUint32(0, ALGORITHM_CONTENT.length);\nALGORITHM_ID.set(Buffer.from(ALGORITHM_CONTENT), 4);\n\n// RFC 7518 Section 4.6.2 specifies using SHA-256 for ECDH-ES KDF\n// https://tools.ietf.org/html/rfc7518#section-4.6.2\nconst HASH_ALGORITHM = { name: 'SHA-256' };\n\n// derived keys are always 256-bits\nconst KEY_LENGTH = 256;\n\n/**\n * Derives a 256-bit AES-KW key encryption key from a shared secret that\n * was derived from an ephemeral and static pair\n * of Elliptic Curve Diffie-Hellman keys.\n *\n * The KDF used is described in RFC 7518. This KDF is referenced by RFC 8037,\n * which defines how to perform Curve25519 (X25519) ECDH key agreement.\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.secret - The shared secret (i.e., `Z`) to use.\n * @param {Uint8Array} options.producerInfo - An array of application-specific\n *   bytes describing the consumer (aka the \"encrypter\" or \"sender\").\n * @param {Uint8Array} options.consumerInfo - An array of application-specific\n *   bytes describing the producer (aka the \"decrypter\" or\n *   \"receiver\"/\"recipient\").\n *\n * @returns {Promise<Uint8Array>} - Resolves to the generated key.\n */\nexport async function deriveKey({ secret, producerInfo, consumerInfo }: any) {\n  if (!(secret instanceof Uint8Array && secret.length > 0)) {\n    throw new TypeError('\"secret\" must be a non-empty Uint8Array.');\n  }\n  if (!(producerInfo instanceof Uint8Array && producerInfo.length > 0)) {\n    throw new TypeError('\"producerInfo\" must be a non-empty Uint8Array.');\n  }\n  if (!(consumerInfo instanceof Uint8Array && consumerInfo.length > 0)) {\n    throw new TypeError('\"consumerInfo\" must be a non-empty Uint8Array.');\n  }\n\n  // the output of Concat KDF is hash(roundNumber || Z || OtherInfo)\n  // where roundNumber is always 1 because the hash length is presumed to\n  // ...match the key length, encoded as a big endian 32-bit integer\n  // where OtherInfo is:\n  // AlgorithmID || PartyUInfo || PartyVInfo || SuppPubInfo\n  // where SuppPubInfo is the key length in bits, big endian encoded as a\n  // 32-bit number, i.e., 256 === [0, 0, 1, 0]\n  const input = new Uint8Array(\n    4 + // round number\n    secret.length + // `Z`\n    ALGORITHM_ID.length + // AlgorithmID\n    4 +\n    producerInfo.length + // PartyUInfo\n    4 +\n    consumerInfo.length + // PartyVInfo\n      4\n  ); // SuppPubInfo (key data length in bits)\n  let offset = 0;\n  const dv = new DataView(input.buffer, input.byteOffset, input.byteLength);\n  dv.setUint32(offset, 1);\n  input.set(secret, (offset += 4));\n  input.set(ALGORITHM_ID, (offset += secret.length));\n  dv.setUint32((offset += ALGORITHM_ID.length), producerInfo.length);\n  input.set(producerInfo, (offset += 4));\n  dv.setUint32((offset += producerInfo.length), consumerInfo.length);\n  input.set(consumerInfo, (offset += 4));\n  dv.setUint32((offset += consumerInfo.length), KEY_LENGTH);\n\n  // hash input and return result as derived key\n  return new Uint8Array(await crypto.subtle.digest(HASH_ALGORITHM, input));\n}\n","import { default as bs64 } from 'base64url';\nimport { AESKW } from '@stablelib/aes-kw';\n\nexport interface CreateKekOptions {\n  keyData: Uint8Array;\n}\n\nexport interface WrapKeyOptions {\n  unwrappedKey: Uint8Array;\n}\n\nexport interface UnwrapKeyOptions {\n  wrappedKey: string; //base64url\n}\n\nexport class KeyEncryptionKey {\n  public aeskw: AESKW;\n  public algorithm: any;\n\n  static createKek = async ({ keyData }: CreateKekOptions) => {\n    return new KeyEncryptionKey(keyData);\n  };\n\n  constructor(key: Uint8Array) {\n    if (key.length !== 32) {\n      throw new Error('key must be 32 bytes');\n    }\n    this.aeskw = new AESKW(key);\n    this.algorithm = { name: 'A256KW' };\n  }\n\n  /**\n   * Wraps a cryptographic key.\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.unwrappedKey - The key material as a\n   *   `Uint8Array`.\n   *\n   * @returns {string} - The base64url-encoded wrapped key bytes.\n   */\n  wrapKey({ unwrappedKey }: WrapKeyOptions): string {\n    const wrappedKey = this.aeskw.wrapKey(unwrappedKey);\n    return bs64.encode(Buffer.from(wrappedKey));\n  }\n\n  /**\n   * Unwraps a cryptographic key.\n   *\n   * @param {object} options - The options to use.\n   * @param {string} options.wrappedKey - The wrapped key material as a\n   *   base64url-encoded string.\n   *\n   * @returns {Uint8Array} - Resolves to the key bytes or null if\n   *   the unwrapping fails because the key does not match.\n   */\n  unwrapKey({ wrappedKey }: UnwrapKeyOptions): Uint8Array | null {\n    const _wrappedKey = bs64.toBuffer(wrappedKey);\n    try {\n      return this.aeskw.unwrapKey(_wrappedKey);\n    } catch (e) {\n      // decryption failed\n      console.error(e);\n      return null;\n    }\n  }\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport crypto from '../crypto';\nimport { XChaCha20Poly1305, KEY_LENGTH } from '@stablelib/xchacha20poly1305';\n\nexport const JWE_ENC = 'XC20P';\n\n/**\n * Generates a content encryption key (CEK). The 256-bit key is intended to be\n * used as a XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) key.\n *\n * @returns {Promise<Uint8Array>} - Resolves to the generated key.\n */\nexport async function generateKey() {\n  // generate content encryption key\n  return crypto.getRandomValues(new Uint8Array(KEY_LENGTH));\n}\n\n/**\n * Encrypts some data. The data will be encrypted using the given\n * 256-bit XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption\n * key (CEK).\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.data - The data to encrypt.\n * @param {Uint8Array} [options.additionalData] - Optional additional\n *   authentication data.\n * @param {Uint8Array} options.cek - The content encryption key to use.\n *\n * @returns {Promise<object>} - Resolves to `{ciphertext, iv, tag}`.\n */\nexport async function encrypt({ data, additionalData, cek }: any) {\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError('\"data\" must be a Uint8Array.');\n  }\n  if (!(cek instanceof Uint8Array)) {\n    throw new TypeError('\"cek\" must be a Uint8Array.');\n  }\n\n  const cipher = new XChaCha20Poly1305(cek);\n  // Note: Uses a random value here as a counter is not viable -- multiple\n  // recipients may be trying to update at the same time and use the same\n  // counter breaking security; using XChaCha20Poly1305 once available will\n  // further reduce chances of a collision as it has a 192-bit IV\n  const iv = crypto.getRandomValues(new Uint8Array(cipher.nonceLength));\n\n  // encrypt data\n  const encrypted = cipher.seal(iv, data, additionalData);\n\n  // split ciphertext and tag\n  const ciphertext = encrypted.subarray(0, encrypted.length - cipher.tagLength);\n  const tag = encrypted.subarray(encrypted.length - cipher.tagLength);\n\n  return {\n    ciphertext,\n    iv,\n    tag,\n  };\n}\n\n/**\n * Decrypts some encrypted data. The data must have been encrypted using\n * the given XChaCha20Poly1305 (draft-irtf-cfrg-xchacha-01) content encryption\n * key (CEK).\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.ciphertext - The data to decrypt.\n * @param {Uint8Array} options.iv - The initialization vector (aka nonce).\n * @param {Uint8Array} options.tag - The authentication tag.\n * @param {Uint8Array} [options.additionalData] - Optional additional\n *   authentication data.\n * @param {Uint8Array} options.cek - The content encryption key to use.\n *\n * @returns {Promise<Uint8Array>} The decrypted data.\n */\nexport async function decrypt({\n  ciphertext,\n  iv,\n  tag,\n  additionalData,\n  cek,\n}: any) {\n  if (!(iv instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"iv\".');\n  }\n  if (!(ciphertext instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"ciphertext\".');\n  }\n  if (!(tag instanceof Uint8Array)) {\n    throw new Error('Invalid or missing \"tag\".');\n  }\n  if (!(cek instanceof Uint8Array)) {\n    throw new TypeError('\"cek\" must be a Uint8Array.');\n  }\n\n  // decrypt `ciphertext`\n  const cipher = new XChaCha20Poly1305(cek);\n  const encrypted = new Uint8Array(ciphertext.length + cipher.tagLength);\n  encrypted.set(ciphertext);\n  encrypted.set(tag, ciphertext.length);\n  return cipher.open(iv, encrypted, additionalData);\n}\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\n\nimport * as recAlgorithm from './algorithms/recommended';\nimport { stringToUint8Array } from './util';\n\nconst CIPHER_ALGORITHMS: any = {\n  [recAlgorithm.cipher.JWE_ENC]: recAlgorithm.cipher,\n};\n\nexport class DecryptTransformer {\n  public keyAgreementKey: any;\n  public KeyPairClass: any;\n\n  constructor({ keyAgreementKey, KeyPairClass }: any = {}) {\n    if (!keyAgreementKey) {\n      throw new TypeError('\"keyAgreementKey\" is a required parameter.');\n    }\n    this.KeyPairClass = KeyPairClass;\n    this.keyAgreementKey = keyAgreementKey;\n  }\n\n  async transform(chunk: any, controller: any) {\n    // assumes `chunk` is an object with a JWE under the `jwe` property\n    if (!(chunk && typeof chunk === 'object')) {\n      throw new TypeError('\"chunk\" must be an object.');\n    }\n    const { jwe } = chunk;\n\n    const data = await this.decrypt(jwe);\n    if (data === null) {\n      const error = new Error('Invalid decryption key.');\n      error.name = 'DataError';\n      throw error;\n    }\n\n    controller.enqueue(data);\n  }\n\n  async decrypt(jwe: any) {\n    // validate JWE\n    if (!(jwe && typeof jwe === 'object')) {\n      throw new TypeError('\"jwe\" must be an object.');\n    }\n    if (typeof jwe.protected !== 'string') {\n      throw new TypeError('\"jwe.protected\" is missing or not a string.');\n    }\n    if (typeof jwe.iv !== 'string') {\n      throw new Error('Invalid or missing \"iv\".');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n      throw new Error('Invalid or missing \"ciphertext\".');\n    }\n    if (typeof jwe.tag !== 'string') {\n      throw new Error('Invalid or missing \"tag\".');\n    }\n\n    // validate encryption header\n    let header;\n    let additionalData;\n    try {\n      // ASCII(BASE64URL(UTF8(JWE Protected Header)))\n      additionalData = stringToUint8Array(jwe.protected);\n      header = JSON.parse(\n        new TextDecoder().decode(base64url.toBuffer(jwe.protected))\n      );\n    } catch (e) {\n      throw new Error('Invalid JWE \"protected\" header.');\n    }\n    if (!(header.enc && typeof header.enc === 'string')) {\n      throw new Error('Invalid JWE \"enc\" header.');\n    }\n    const cipher = CIPHER_ALGORITHMS[header.enc];\n    if (!cipher) {\n      throw new Error('Unsupported encryption algorithm \"${header.enc}\".');\n    }\n    if (!Array.isArray(jwe.recipients)) {\n      throw new TypeError('\"jwe.recipients\" must be an array.');\n    }\n\n    // find `keyAgreementKey` matching recipient\n    const { keyAgreementKey } = this;\n\n    const _findRecipient = (recipients: any, key: any) => {\n      return recipients.find(\n        (rec: any) =>\n          (rec.header && rec.header.kid === key.id) ||\n          rec.header.kid.split('#').pop() === key.id.split('#').pop()\n      );\n    };\n\n    const recipient = _findRecipient(jwe.recipients, keyAgreementKey);\n\n    if (!recipient) {\n      console.log(jwe.recipients, keyAgreementKey);\n      throw new Error('No matching recipient found for key agreement key.');\n    }\n    // get wrapped CEK\n    const { encrypted_key: wrappedKey } = recipient;\n    if (typeof wrappedKey !== 'string') {\n      throw new Error('Invalid or missing \"encrypted_key\".');\n    }\n\n    // TODO: consider a cache of encrypted_key => CEKs to reduce unwrapping\n    // calls which may even need to hit the network (e.g., Web KMS)\n\n    // derive KEK and unwrap CEK\n    const { epk } = recipient.header;\n\n    const { kek } = await this.KeyPairClass.kekFromEphemeralPeer({\n      keyAgreementKey,\n      epk,\n    });\n    const cek = await kek.unwrapKey({ wrappedKey });\n    if (!cek) {\n      // failed to unwrap key\n      return null;\n    }\n\n    // decrypt content\n    const { ciphertext, iv, tag } = jwe;\n    return cipher.decrypt({\n      ciphertext: base64url.toBuffer(ciphertext),\n      iv: base64url.toBuffer(iv),\n      tag: base64url.toBuffer(tag),\n      additionalData,\n      cek,\n    });\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/*!\n * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.\n */\nimport base64url from 'base64url';\n\n// 1 MiB = 1048576\nconst DEFAULT_CHUNK_SIZE = 1048576;\n\nexport class EncryptTransformer {\n  public recipients: any;\n  public encodedProtectedHeader: any;\n  public cipher: any;\n  public additionalData: any;\n  public cek: any;\n  public chunkSize: any;\n  public offset: any;\n  public totalOffset: any;\n  public index: any;\n  public buffer: any;\n\n  constructor({\n    recipients,\n    encodedProtectedHeader,\n    cipher,\n    additionalData,\n    cek,\n    chunkSize = DEFAULT_CHUNK_SIZE,\n  }: any = {}) {\n    this.recipients = recipients;\n    this.encodedProtectedHeader = encodedProtectedHeader;\n    this.cipher = cipher;\n    this.additionalData = additionalData;\n    this.cek = cek;\n    this.chunkSize = chunkSize;\n    this.offset = 0;\n    this.totalOffset = 0;\n    this.index = 0;\n  }\n\n  start() {\n    this.buffer = new Uint8Array(this.chunkSize);\n  }\n\n  async transform(chunk: any, controller: any) {\n    const { buffer } = this;\n\n    // assumes `chunk` is a Uint8Array...\n    if (!(chunk instanceof Uint8Array)) {\n      throw new TypeError('\"chunk\" must be an object.');\n    }\n    while (chunk) {\n      const space = buffer.length - this.offset;\n      if (chunk.length <= space) {\n        buffer.set(chunk, this.offset);\n        this.offset += chunk.byteLength;\n        this.totalOffset += chunk.byteLength;\n        chunk = null;\n      } else {\n        const partial = new Uint8Array(chunk.buffer, chunk.byteOffset, space);\n        chunk = new Uint8Array(\n          chunk.buffer,\n          chunk.byteOffset + space,\n          chunk.length - space\n        );\n        buffer.set(partial, this.offset);\n        this.offset += space;\n        this.totalOffset += space;\n      }\n\n      // flush if buffer is full and more data remains\n      if (chunk) {\n        await this.flush(controller);\n      }\n    }\n  }\n\n  async flush(controller: any) {\n    if (this.offset === 0) {\n      // nothing to flush\n      return;\n    }\n\n    // encrypt data\n    const { buffer } = this;\n    const data = new Uint8Array(buffer.buffer, buffer.byteOffset, this.offset);\n    const jwe = await this.encrypt(data);\n\n    // clear buffer\n    this.offset = 0;\n\n    controller.enqueue({\n      index: this.index++,\n      offset: this.totalOffset,\n      jwe,\n    });\n  }\n\n  async encrypt(data: any) {\n    const { cipher, additionalData, cek } = this;\n    const { ciphertext, iv, tag } = await cipher.encrypt({\n      data,\n      additionalData,\n      cek,\n    });\n\n    // represent encrypted data as JWE\n    const jwe = {\n      protected: this.encodedProtectedHeader,\n      recipients: this.recipients,\n      iv: base64url.encode(iv),\n      ciphertext: base64url.encode(ciphertext),\n      tag: base64url.encode(tag),\n    };\n    return jwe;\n  }\n}\n","import { KeyPairClass, EpkResult } from '../types';\n\nexport const getEpkGenerator = (KeyPair: KeyPairClass, opts: any) => {\n  const generateEphemeralKeyPair = async (): Promise<EpkResult> => {\n    const k0 = await KeyPair.generate(opts);\n    const keypair = await k0.toJsonWebKey(true);\n\n    return {\n      keypair,\n      epk: keypair.publicKeyJwk,\n    };\n  };\n  return generateEphemeralKeyPair;\n};\n","/* eslint-disable */\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost'\n    // [::1] is the IPv6 localhost address.\n    || window.location.hostname === '[::1]'\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    || window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service '\n              + 'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all '\n                  + 'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404\n        || (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import { createBrowserHistory } from 'history';\n\nexport default createBrowserHistory();\n","import { createAction } from 'redux-actions';\n\nexport const setUniversalWalletProp = createAction(\n  'universal-wallet/SET_UNIVERSAL_WALLET_PROP',\n  (payload) => payload\n);\n","import { handleActions } from \"redux-actions\";\nimport { setUniversalWalletProp } from \"./actions\";\n\nconst initialState = {\n  name: \"UniversalWallet2020\",\n  status: \"UNLOCKED\",\n  contents: [],\n  vaultEndpoint: \"https://edv.did.ai/edvs\",\n  isSyncEnabled: true,\n  isSyncing: false,\n};\n\nexport default handleActions(\n  {\n    [setUniversalWalletProp]: (state, { payload }) => ({\n      ...state,\n      ...payload,\n    }),\n  },\n  initialState\n);\n","import { connect } from 'react-redux';\nimport * as actions from './actions';\n\nexport default connect(({ wallet }) => ({ wallet }), { ...actions });\n","import reducer from './reducer';\nimport container from './container';\n\nexport default {\n  reducer,\n  container,\n};\n","import { compose } from 'recompose';\nimport withRedux from './redux';\nimport withHandlers from './handlers';\n\nexport default compose(withRedux, withHandlers);\n","import { connectRouter } from \"connected-react-router\";\n\nimport history from \"./history\";\n\nimport wallet from \"./universal-wallet\";\n\nexport default {\n  router: connectRouter(history),\n  wallet: wallet.reducer,\n};\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nimport { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles';\n\nimport { darken, lighten } from '@material-ui/core/styles/colorManipulator';\n\nconst primaryColor = '#594aa8';\nconst secondaryColor = '#fcb373';\n\nconst font1 = '\"Rajdhani\"';\nconst font2 = '\"Roboto Condensed\"';\nconst font3 = '\"Lato\"';\n\nconst fontWeightLight = 300;\nconst fontWeightRegular = 400;\nconst fontWeightMedium = 600;\n\nclass Theme extends Component {\n  render() {\n    const { children } = this.props;\n    const theme = createMuiTheme({\n      splashImage: '',\n      palette: {\n        type: 'light',\n        primary: {\n          light: lighten(primaryColor, 0.07),\n          main: primaryColor,\n          dark: darken(primaryColor, 0.07),\n        },\n        secondary: {\n          light: lighten(secondaryColor, 0.07),\n          main: secondaryColor,\n          dark: darken(secondaryColor, 0.07),\n        },\n      },\n      typography: {\n        useNextVariants: true,\n        fontSize: 16,\n        fontFamily: [font1, font2, font3].join(','),\n        h1: {\n          fontFamily: font1,\n          fontWeight: fontWeightMedium,\n        },\n        h2: {\n          fontFamily: font1,\n          fontWeight: fontWeightMedium,\n        },\n        h3: {\n          fontFamily: font1,\n          fontWeight: fontWeightMedium,\n        },\n        h4: {\n          fontFamily: font2,\n          textTransform: 'uppercase',\n          letterSpacing: '0.1em',\n          fontWeight: fontWeightRegular,\n        },\n        h5: {\n          fontFamily: font2,\n          textTransform: 'uppercase',\n          letterSpacing: '0.1em',\n          fontWeight: fontWeightRegular,\n        },\n        h6: {\n          fontFamily: font2,\n          textTransform: 'uppercase',\n          letterSpacing: '0.05em',\n          fontWeight: fontWeightRegular,\n        },\n        subtitle1: {\n          fontFamily: font1,\n          fontWeight: fontWeightRegular,\n        },\n        subtitle2: {\n          fontFamily: font2,\n          fontWeight: fontWeightRegular,\n        },\n        body1: {\n          fontFamily: font3,\n          fontWeight: fontWeightRegular,\n        },\n        body2: {\n          fontFamily: font3,\n          fontWeight: fontWeightRegular,\n        },\n        button: {\n          fontFamily: font2,\n          fontWeight: fontWeightRegular,\n        },\n        caption: {\n          fontFamily: font2,\n          fontWeight: fontWeightRegular,\n        },\n        overline: {\n          fontFamily: font2,\n          letterSpacing: '0.15em',\n          textTransform: 'uppercase',\n          fontWeight: fontWeightLight,\n        },\n      },\n\n      overrides: {\n        MuiInput: {\n          // Name of the component ⚛️ / style sheet\n          input: {\n            fontFamily: font3,\n          },\n        },\n        MuiInputLabel: {\n          // Name of the component ⚛️ / style sheet\n          root: {\n            fontFamily: font2,\n          },\n        },\n        MuiAppBar: {\n          root: {\n            // boxShadow: 'none',\n          },\n        },\n        MuiButton: {\n          // Name of the rule\n          contained: {\n            boxShadow: 'none',\n          },\n        },\n      },\n    });\n    return <MuiThemeProvider theme={theme}>{children}</MuiThemeProvider>;\n  }\n}\n\nTheme.propTypes = {\n  children: PropTypes.any.isRequired,\n};\n\nexport default Theme;\n","import React from \"react\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport Menu from \"@material-ui/core/Menu\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\nimport MoreVertIcon from \"@material-ui/icons/MoreVert\";\nimport HomeIcon from \"@material-ui/icons/Home\";\n\nimport history from \"../../store/history\";\n\nconst StyledMenu = withStyles({\n  paper: {\n    border: \"1px solid #d3d4d5\",\n  },\n})((props) => (\n  <Menu\n    elevation={0}\n    getContentAnchorEl={null}\n    anchorOrigin={{\n      vertical: \"bottom\",\n      horizontal: \"center\",\n    }}\n    transformOrigin={{\n      vertical: \"top\",\n      horizontal: \"center\",\n    }}\n    {...props}\n  />\n));\n\nconst StyledMenuItem = withStyles((theme) => ({\n  root: {\n    \"&:focus\": {\n      backgroundColor: theme.palette.primary.main,\n      \"& .MuiListItemIcon-root, & .MuiListItemText-primary\": {\n        color: theme.palette.common.white,\n      },\n    },\n  },\n}))(MenuItem);\n\nexport default function CustomizedMenus() {\n  const [anchorEl, setAnchorEl] = React.useState(null);\n\n  const handleClick = (event) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  return (\n    <div>\n      <IconButton\n        color={\"inherit\"}\n        aria-controls=\"customized-menu\"\n        aria-haspopup=\"true\"\n        onClick={handleClick}\n      >\n        <MoreVertIcon />\n      </IconButton>\n      <StyledMenu\n        id=\"customized-menu\"\n        anchorEl={anchorEl}\n        keepMounted\n        open={Boolean(anchorEl)}\n        onClose={handleClose}\n      >\n        <StyledMenuItem\n          onClick={() => {\n            history.push(\"/workbench\");\n          }}\n        >\n          <ListItemIcon>\n            <HomeIcon fontSize=\"small\" />\n          </ListItemIcon>\n          <ListItemText primary=\"Workbench\" />\n        </StyledMenuItem>\n      </StyledMenu>\n    </div>\n  );\n}\n","import React from \"react\";\n\nimport List from \"@material-ui/core/List\";\nimport ListItem from \"@material-ui/core/ListItem\";\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\nimport HomeIcon from \"@material-ui/icons/Home\";\nimport HttpIcon from \"@material-ui/icons/Http\";\nimport CodeIcon from \"@material-ui/icons/Code\";\nimport GavelIcon from \"@material-ui/icons/Gavel\";\nimport BuildIcon from \"@material-ui/icons/Build\";\nimport PictureAsPdfIcon from \"@material-ui/icons/PictureAsPdf\";\nimport YouTubeIcon from \"@material-ui/icons/YouTube\";\nimport history from \"../../store/history\";\n\nexport default function DrawerContent() {\n  return (\n    <List>\n      <ListItem\n        button\n        onClick={() => {\n          history.push(\"/\");\n        }}\n      >\n        <ListItemIcon>\n          <HomeIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Home\"} />\n      </ListItem>\n\n      <ListItem\n        button\n        onClick={() => {\n          history.push(\"/workbench\");\n        }}\n      >\n        <ListItemIcon>\n          <BuildIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Workbench\"} />\n      </ListItem>\n\n      <ListItem\n        button\n        onClick={() => {\n          history.push(\"/offline\");\n        }}\n      >\n        <ListItemIcon>\n          <PictureAsPdfIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"PDF Demo\"} />\n      </ListItem>\n\n      <ListItem\n        button\n        onClick={() => {\n          history.push(\"/videos\");\n        }}\n      >\n        <ListItemIcon>\n          <YouTubeIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Videos\"} />\n      </ListItem>\n\n      <ListItem\n        button\n        onClick={() => {\n          window.open(\"https://w3c-ccg.github.io/did-method-key/\");\n        }}\n      >\n        <ListItemIcon>\n          <GavelIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Spec\"} />\n      </ListItem>\n\n      <ListItem\n        button\n        onClick={() => {\n          window.open(\"https://did-key.web.app/api/docs\");\n        }}\n      >\n        <ListItemIcon>\n          <HttpIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"API\"} />\n      </ListItem>\n\n      <ListItem\n        button\n        onClick={() => {\n          window.open(\"https://github.com/transmute-industries/did-key.js\");\n        }}\n      >\n        <ListItemIcon>\n          <CodeIcon />\n        </ListItemIcon>\n        <ListItemText primary={\"Code\"} />\n      </ListItem>\n    </List>\n  );\n}\n","import React from 'react';\nimport clsx from 'clsx';\nimport { makeStyles, useTheme } from '@material-ui/core/styles';\nimport Drawer from '@material-ui/core/Drawer';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\n\nimport CssBaseline from '@material-ui/core/CssBaseline';\n\nimport Divider from '@material-ui/core/Divider';\nimport IconButton from '@material-ui/core/IconButton';\nimport MenuIcon from '@material-ui/icons/Menu';\nimport ChevronLeftIcon from '@material-ui/icons/ChevronLeft';\nimport ChevronRightIcon from '@material-ui/icons/ChevronRight';\n\nimport Theme from '../../components/Theme/Theme';\nimport logo from '../../assets/logo.svg';\n\nimport Menu from './menu';\nimport DrawerContent from './drawer';\n\nconst drawerWidth = 240;\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: 'flex',\n    width: '100%',\n  },\n  appBar: {\n    zIndex: theme.zIndex.drawer + 1,\n    transition: theme.transitions.create(['width', 'margin'], {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.leavingScreen,\n    }),\n  },\n  appBarShift: {\n    marginLeft: drawerWidth,\n    width: `calc(100% - ${drawerWidth}px)`,\n    transition: theme.transitions.create(['width', 'margin'], {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.enteringScreen,\n    }),\n  },\n  menuButton: {\n    marginRight: 36,\n  },\n  hide: {\n    display: 'none',\n  },\n  drawer: {\n    width: drawerWidth,\n    flexShrink: 0,\n    whiteSpace: 'nowrap',\n  },\n  drawerOpen: {\n    width: drawerWidth,\n    transition: theme.transitions.create('width', {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.enteringScreen,\n    }),\n  },\n  drawerClose: {\n    transition: theme.transitions.create('width', {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.leavingScreen,\n    }),\n    overflowX: 'hidden',\n    width: theme.spacing(7) + 1,\n    [theme.breakpoints.up('sm')]: {\n      width: theme.spacing(9) + 1,\n    },\n  },\n  toolbar: {\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'flex-end',\n    padding: theme.spacing(0, 1),\n    // necessary for content to be below app bar\n    ...theme.mixins.toolbar,\n  },\n  content: {\n    flexGrow: 1,\n    padding: theme.spacing(3),\n  },\n}));\n\nexport default function MiniDrawer({ children }) {\n  const classes = useStyles();\n  const theme = useTheme();\n  const [open, setOpen] = React.useState(false);\n\n  const handleDrawerOpen = () => {\n    setOpen(true);\n  };\n\n  const handleDrawerClose = () => {\n    setOpen(false);\n  };\n\n  return (\n    <Theme>\n      <div className={classes.root}>\n        <CssBaseline />\n        <AppBar\n          position=\"fixed\"\n          className={clsx(classes.appBar, {\n            [classes.appBarShift]: open,\n          })}\n        >\n          <Toolbar>\n            <IconButton\n              color=\"inherit\"\n              aria-label=\"open drawer\"\n              onClick={handleDrawerOpen}\n              edge=\"start\"\n              className={clsx(classes.menuButton, {\n                [classes.hide]: open,\n              })}\n            >\n              <MenuIcon />\n            </IconButton>\n            <img\n              src={logo}\n              alt={'logo'}\n              className={classes.title}\n              style={{ height: '28px' }}\n            />\n            <div style={{ flexGrow: 1 }}></div>\n            <Menu />\n          </Toolbar>\n        </AppBar>\n        <Drawer\n          variant=\"permanent\"\n          className={clsx(classes.drawer, {\n            [classes.drawerOpen]: open,\n            [classes.drawerClose]: !open,\n          })}\n          classes={{\n            paper: clsx({\n              [classes.drawerOpen]: open,\n              [classes.drawerClose]: !open,\n            }),\n          }}\n        >\n          <div className={classes.toolbar}>\n            <IconButton onClick={handleDrawerClose}>\n              {theme.direction === 'rtl' ? (\n                <ChevronRightIcon />\n              ) : (\n                <ChevronLeftIcon />\n              )}\n            </IconButton>\n          </div>\n          <Divider />\n          <DrawerContent />\n        </Drawer>\n        <main className={classes.content}>\n          <div className={classes.toolbar} />\n          {children}\n        </main>\n      </div>\n    </Theme>\n  );\n}\n","import crypto from \"crypto\";\nimport * as ed25519 from \"@transmute/did-key-ed25519\";\nimport * as x25519 from \"@transmute/did-key-x25519\";\nimport * as secp256k1 from \"@transmute/did-key-secp256k1\";\nimport * as bls12381 from \"@transmute/did-key-bls12381\";\nimport * as didKeyWebCrypto from \"@transmute/did-key-web-crypto\";\n\nexport const generateX25519 = async () => {\n  const x25519KeyPair = await x25519.X25519KeyPair.generate({\n    secureRandom: () => {\n      return crypto.randomBytes(32);\n    },\n  });\n  const didDocument = x25519.driver.keyToDidDoc(x25519KeyPair);\n  return {\n    keys: {\n      key: x25519KeyPair.toKeyPair(true),\n    },\n    didDocument,\n  };\n};\n\nexport const generateEd25519 = async () => {\n  const ed25519Key = await ed25519.Ed25519KeyPair.generate({\n    secureRandom: () => {\n      return crypto.randomBytes(32);\n    },\n  });\n  const didDocument = ed25519.driver.keyToDidDoc(ed25519Key);\n  return {\n    keys: {\n      ed25519: await ed25519Key.toKeyPair(true),\n      x25519: (await x25519.X25519KeyPair.fromEdKeyPair(ed25519Key)).toKeyPair(\n        true\n      ),\n    },\n    didDocument,\n  };\n};\n\nexport const generateSecp256k1 = async () => {\n  const secp256k1Key = await secp256k1.Secp256k1KeyPair.generate({\n    secureRandom: () => {\n      return crypto.randomBytes(32);\n    },\n  });\n  const didDocument = secp256k1.driver.keyToDidDoc(secp256k1Key);\n  const keys = {\n    key: secp256k1Key.toKeyPair(true),\n  };\n  return {\n    keys,\n    didDocument,\n  };\n};\n\nexport const generateBls12381 = async () => {\n  const bls12381G2Key = await bls12381.Bls12381G2KeyPair.generate();\n  const didDocument = bls12381.driver.keyToDidDoc(bls12381G2Key);\n  const keys = {\n    key: await bls12381.Bls12381G2KeyPair.toKeyPair(bls12381G2Key),\n  };\n  return {\n    keys,\n    didDocument,\n  };\n};\n\nexport const generateP256 = async () => {\n  const keypair = await didKeyWebCrypto.KeyPair.generate({\n    kty: \"EC\",\n    crvOrSize: \"P-256\",\n  });\n  const keys = {\n    key: await keypair.toJsonWebKey(true),\n  };\n  const didDocument = await didKeyWebCrypto.driver.get({\n    did: keys.key.controller,\n  });\n  return {\n    keys,\n    didDocument,\n  };\n};\n\nexport const generateP384 = async () => {\n  const keypair = await didKeyWebCrypto.KeyPair.generate({\n    kty: \"EC\",\n    crvOrSize: \"P-384\",\n  });\n  const keys = {\n    key: await keypair.toJsonWebKey(true),\n  };\n  const didDocument = await didKeyWebCrypto.driver.get({\n    did: keys.key.controller,\n  });\n  return {\n    keys,\n    didDocument,\n  };\n};\n\nexport const generateP521 = async () => {\n  const keypair = await didKeyWebCrypto.KeyPair.generate({\n    kty: \"EC\",\n    crvOrSize: \"P-521\",\n  });\n  const keys = {\n    key: await keypair.toJsonWebKey(true),\n  };\n  const didDocument = await didKeyWebCrypto.driver.get({\n    did: keys.key.controller,\n  });\n  return {\n    keys,\n    didDocument,\n  };\n};\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Button from \"@material-ui/core/Button\";\nimport Base from \"../base/base\";\n\nimport { DIDDocumentPreview, JSONEditor } from \"@transmute/material-did-core\";\n\nimport * as util from \"./util\";\n\nexport const Home = (props) => {\n  const [state, setState] = React.useState({\n    keys: null,\n    didDocument: null,\n  });\n\n  const generateEd25519 = async () => {\n    (async () => {\n      const { keys, didDocument } = await util.generateEd25519();\n      setState((state) => {\n        return {\n          ...state,\n          keys,\n          didDocument,\n        };\n      });\n    })();\n  };\n\n  const generateX25519 = async () => {\n    (async () => {\n      const { keys, didDocument } = await util.generateX25519();\n      setState((state) => {\n        return {\n          ...state,\n          keys,\n          didDocument,\n        };\n      });\n    })();\n  };\n\n  const generateSecp256k1 = async () => {\n    (async () => {\n      const { keys, didDocument } = await util.generateSecp256k1();\n      setState((state) => {\n        return {\n          ...state,\n          keys,\n          didDocument,\n        };\n      });\n    })();\n  };\n\n  const generateBls12381 = async () => {\n    (async () => {\n      const { keys, didDocument } = await util.generateBls12381();\n      setState((state) => {\n        return {\n          ...state,\n          keys,\n          didDocument,\n        };\n      });\n    })();\n  };\n\n  const generateP256 = async () => {\n    (async () => {\n      const { keys, didDocument } = await util.generateP256();\n      setState((state) => {\n        return {\n          ...state,\n          keys,\n          didDocument,\n        };\n      });\n    })();\n  };\n\n  const generateP384 = async () => {\n    (async () => {\n      const { keys, didDocument } = await util.generateP384();\n      setState((state) => {\n        return {\n          ...state,\n          keys,\n          didDocument,\n        };\n      });\n    })();\n  };\n\n  const generateP521 = async () => {\n    (async () => {\n      const { keys, didDocument } = await util.generateP521();\n      setState((state) => {\n        return {\n          ...state,\n          keys,\n          didDocument,\n        };\n      });\n    })();\n  };\n\n  React.useEffect(() => {\n    if (state.keys === null) {\n      generateEd25519();\n    }\n  });\n  if (!props.wallet) {\n    return <div>loading...</div>;\n  }\n  return (\n    <Base>\n      <Grid container spacing={4}>\n        <Grid item sm={12} xs={12}>\n          <Button\n            variant={\"contained\"}\n            style={{ marginRight: \"8px\" }}\n            onClick={() => {\n              generateEd25519();\n            }}\n          >\n            Ed25519\n          </Button>\n\n          <Button\n            variant={\"contained\"}\n            style={{ marginRight: \"8px\" }}\n            onClick={() => {\n              generateX25519();\n            }}\n          >\n            X25519\n          </Button>\n\n          <Button\n            variant={\"contained\"}\n            style={{ marginRight: \"8px\" }}\n            onClick={() => {\n              generateSecp256k1();\n            }}\n          >\n            Secp256k1\n          </Button>\n          <Button\n            variant={\"contained\"}\n            style={{ marginRight: \"8px\" }}\n            onClick={() => {\n              generateBls12381();\n            }}\n          >\n            Bls12381\n          </Button>\n\n          <Button\n            variant={\"contained\"}\n            style={{ marginRight: \"8px\" }}\n            onClick={() => {\n              generateP256();\n            }}\n          >\n            P-256\n          </Button>\n          <Button\n            variant={\"contained\"}\n            style={{ marginRight: \"8px\" }}\n            onClick={() => {\n              generateP384();\n            }}\n          >\n            P-384\n          </Button>\n          <Button\n            variant={\"contained\"}\n            style={{ marginRight: \"8px\" }}\n            onClick={() => {\n              generateP521();\n            }}\n          >\n            P-521\n          </Button>\n        </Grid>\n\n        {state.didDocument !== null && (\n          <Grid item sm={12} xs={12}>\n            <Typography variant={\"h6\"} gutterBottom>\n              DID Document\n            </Typography>\n            <DIDDocumentPreview didDocument={state.didDocument} />\n          </Grid>\n        )}\n        <Grid item sm={12} xs={12}>\n          <Typography variant={\"h6\"} gutterBottom>\n            Key\n          </Typography>\n          <JSONEditor value={JSON.stringify(state.keys, null, 2)} />\n        </Grid>\n      </Grid>\n    </Base>\n  );\n};\n\nHome.propTypes = {\n  wallet: PropTypes.any,\n};\n","import { Home } from \"./home\";\n// import { Workbench } from \"./workbench\";\n// import { PdfDemo } from \"./pdf\";\n// import { Videos } from \"./videos\";\n\nexport const routes = [\n  { path: \"/\", exact: true, component: Home },\n  // { path: \"/workbench\", exact: true, component: Workbench },\n  // { path: \"/offline\", exact: true, component: PdfDemo },\n  // { path: \"/videos\", exact: true, component: Videos },\n];\n","import React from \"react\";\nimport { Home as Page } from \"./Home\";\n\nimport { compose } from \"redux\";\n\nimport wallet from \"../../store/universal-wallet\";\n\nconst container = compose(wallet.container);\n\nexport const Home = container((props) => {\n  return <Page {...props} />;\n});\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nimport Particles from 'react-particles-js';\n\nexport class ParticlesContainer extends Component {\n  render() {\n    const params = this.props.params || {\n      particles: {\n        line_linked: {\n          shadow: {\n            enable: true,\n            color: '#3CA9D1',\n            blur: 5,\n          },\n        },\n      },\n    };\n    return (\n      <React.Fragment>\n        <div\n          style={{\n            zIndex: 2,\n            position: 'absolute',\n          }}\n        >\n          {this.props.children}\n        </div>\n\n        <Particles\n          className=\"Particles\"\n          style={{\n            zIndex: 1,\n            top: 0,\n            position: 'absolute',\n          }}\n          params={params}\n        />\n      </React.Fragment>\n    );\n  }\n}\n\nParticlesContainer.propTypes = {\n  params: PropTypes.object,\n  children: PropTypes.any,\n};\n","import React, { Component } from 'react';\nimport Button from '@material-ui/core/Button';\nimport Typography from '@material-ui/core/Typography';\nimport Theme from '../../components/Theme/Theme';\n\nimport { ParticlesContainer } from '../../components/ParticlesContainer';\n\nimport './404.css';\n\nexport class NotFound extends Component {\n  render() {\n    return (\n      <Theme>\n        <div className=\"notFound\">\n          <ParticlesContainer>\n            <div className=\"copy\" style={{ padding: '32px' }}>\n              <Typography variant=\"h1\">404</Typography>\n              <Typography>\n                {window.location.pathname} page not found.\n              </Typography>\n              <br />\n              <Button\n                variant=\"contained\"\n                color={'secondary'}\n                onClick={() => {\n                  window.location.href = '/workbench';\n                }}\n              >\n                Go Home\n              </Button>\n            </div>\n          </ParticlesContainer>\n        </div>\n      </Theme>\n    );\n  }\n}\n\nexport default NotFound;\n","import { createStore, combineReducers, applyMiddleware, compose } from \"redux\";\nimport { persistStore, persistReducer } from \"redux-persist\";\nimport { routerMiddleware } from \"connected-react-router\";\nimport storage from \"redux-persist/lib/storage\";\nimport { composeWithDevTools } from \"redux-devtools-extension\";\nimport thunk from \"redux-thunk\";\nimport withReduxEnhancer from \"addon-redux/enhancer\";\n\nimport rootReducer from \".\";\nimport history from \"./history\";\n\nexport default (appReducers = {}) => {\n  // Persistance configuration\n  const persistConfig = {\n    key: \"root\",\n    whitelist: [\"wallet\"],\n    storage,\n  };\n\n  const middlewares = [thunk, routerMiddleware(history)];\n\n  // TODO: refactor for production\n  if (process.env.NODE_ENV !== \"production\") {\n    // const reduxListener = createStorybookListener();\n    // middlewares.push(reduxListener);\n  }\n\n  // Store.\n  const store = createStore(\n    persistReducer(\n      persistConfig,\n      combineReducers({ ...rootReducer, ...appReducers })\n    ),\n    composeWithDevTools(\n      compose(applyMiddleware(...middlewares), withReduxEnhancer)\n    )\n  );\n\n  // Persistor.\n  const persistor = persistStore(store);\n  return {\n    store,\n    persistor,\n    history,\n  };\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n\nimport { Switch, Route } from \"react-router-dom\";\nimport { ConnectedRouter } from \"connected-react-router\";\nimport { Provider } from \"react-redux\";\nimport { PersistGate } from \"redux-persist/lib/integration/react\";\n\nimport * as serviceWorker from \"./serviceWorker\";\n\nimport createStore from \"./store/create\";\n\nimport { routes } from \"./pages\";\n\nimport { NotFound } from \"./pages/errors/404\";\n\nconst { store, persistor, history } = createStore();\n\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate persistor={persistor}>\n      <ConnectedRouter history={history}>\n        <Switch>\n          {routes.map(({ exact, path, component }) => (\n            <Route key={path} exact={exact} path={path} component={component} />\n          ))}\n          <Route path=\"*\" render={() => <NotFound />} />\n        </Switch>\n      </ConnectedRouter>\n    </PersistGate>\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\nconsole.log(\n  `\nHello Developer 🧙‍♂️! \nCheckout our corporate website if you are interested in working with us: \n✨ https://www.transmute.industries/\n`\n);\n","// See https://github.com/multiformats/multicodec/pull/190\n\nexport const SUPPORTED_EC = [\n  'P-256',\n  'P-384',\n  'P-521',\n  // not currently supported by web crypto\n  // 'Ed448', 'X448'\n];\n\nexport const multicodecPrefix = 0x12;\n\nexport const crvToMulticodecPrefix: any = {\n  'P-256': 0x00,\n  'P-384': 0x01,\n  'P-521': 0x02,\n  // Ed448: 0x03,\n  // X448: 0x04,\n};\n\nexport const multicodecToJwkType: any = {\n  0x00: { kty: 'EC', crv: 'P-256' },\n  0x01: { kty: 'EC', crv: 'P-384' },\n  0x02: { kty: 'EC', crv: 'P-521' },\n  // 0x03: { kty: 'OKP', crv: 'Ed448' },\n  // 0x04: { kty: 'OKP', crv: 'X448' },\n};\n\nexport const crvToJwsAlg: any = {\n  'P-256': 'ES256',\n  'P-384': 'ES384',\n  'P-521': 'ES521',\n};\n\nexport const crvToJwsHashAlg: any = {\n  'P-256': 'SHA-256',\n  'P-384': 'SHA-384',\n  'P-521': 'SHA-512',\n};\n","import { Crypto } from 'node-webcrypto-ossl';\n\nfunction isNodejs() {\n  return (\n    typeof process === 'object' &&\n    typeof process.versions === 'object' &&\n    typeof process.versions.node !== 'undefined'\n  );\n}\n\nlet crypto: Crypto;\n\nif (isNodejs()) {\n  crypto = new Crypto();\n} else {\n  crypto = window.crypto as Crypto;\n}\n\nexport default crypto;\n","import bs58 from 'bs58';\nimport base64url from 'base64url';\n\nimport { types } from '@transmute/did-key-cipher';\n\nexport const jwkToBase58 = (jwk: any): types.LinkedDataKeyPair => {\n  let keypair: any = {};\n  if (jwk.d) {\n    keypair.privateKeyBase58 = bs58.encode(\n      Buffer.concat([base64url.toBuffer(jwk.d)])\n    );\n  }\n  if (jwk.x) {\n    keypair.publicKeyBase58 = bs58.encode(\n      Buffer.concat([base64url.toBuffer(jwk.x)])\n    );\n  }\n  if (jwk.x && jwk.y) {\n    keypair.publicKeyBase58 = bs58.encode(\n      Buffer.concat([base64url.toBuffer(jwk.x), base64url.toBuffer(jwk.y)])\n    );\n  }\n\n  return keypair;\n};\n","export const fingerprintToDid = (fingerprint: string, methodName = 'key') => {\n  return `did:${methodName}:${fingerprint}`;\n};\n","import { types } from '@transmute/did-key-cipher';\nimport { jwkToBase58 } from './jwkToBase58';\nimport { getMultibaseFromJwk } from './getMultibaseFromJwk';\nimport { fingerprintToDid } from './fingerprintToDid';\n\nexport const fromJwk = (jwk: any): types.LinkedDataKeyPair => {\n  const id = getMultibaseFromJwk(jwk);\n  const controller = fingerprintToDid(id);\n  return {\n    id: `#${id}`,\n    type: 'JsonWebKey2020',\n    controller,\n    ...(jwkToBase58(jwk) as any),\n  };\n};\n","import bs58 from 'bs58';\n\nimport { crvToMulticodecPrefix } from '../constants';\nimport { jwkToBase58 } from './jwkToBase58';\n\nexport const getMultibaseFromJwk = (publicKeyJwk: any): string => {\n  const { publicKeyBase58 } = jwkToBase58(publicKeyJwk);\n  const publicKeyBytes = bs58.decode(publicKeyBase58);\n  const prefix = crvToMulticodecPrefix[publicKeyJwk.crv];\n  const buffer = new Uint8Array(3 + publicKeyBytes.length);\n  // https://github.com/multiformats/multicodec/pull/190\n  buffer[0] = 0x12;\n  buffer[1] = prefix;\n  buffer[2] = 0x01;\n  buffer.set(publicKeyBytes, 3);\n  // prefix with `z` to indicate multi-base base58btc encoding\n  return `z${bs58.encode(buffer)}`;\n};\n","import bs58 from 'bs58';\nimport base64url from 'base64url';\n\nimport { types } from '@transmute/did-key-cipher';\n\nexport const base58KeyPairToJwk = (\n  keypair: types.LinkedDataKeyPair\n): object => {\n  const publicKeyBuffer = bs58.decode(keypair.publicKeyBase58);\n\n  const x = base64url.encode(\n    publicKeyBuffer.slice(0, publicKeyBuffer.length / 2)\n  );\n\n  const y = base64url.encode(publicKeyBuffer.slice(publicKeyBuffer.length / 2));\n\n  let jwk: any = { x, y };\n\n  if (keypair.privateKeyBase58) {\n    jwk.d = base64url.encode(bs58.decode(keypair.privateKeyBase58));\n  }\n\n  return jwk;\n};\n","import bs58 from 'bs58';\nimport { multicodecToJwkType } from '../constants';\nexport const getJwkTypeFromMultibase = (fingerprint: string) => {\n  const buffer = bs58.decode(fingerprint.substring(1));\n\n  if (buffer[0] !== 0x12) {\n    throw new Error(`Unsupported multibase ${buffer[0].toString(16)}`);\n  }\n\n  const type = multicodecToJwkType[buffer[1]];\n  if (!type) {\n    throw new Error(\n      `Unsupported multibase ${buffer[0].toString(16)} ${buffer[1].toString(\n        16\n      )}`\n    );\n  }\n  return type;\n};\n","import { types } from '@transmute/did-key-cipher';\nimport { base58KeyPairToJwk } from './base58KeyPairToJwk';\nimport { getJwkTypeFromMultibase } from './getJwkTypeFromMultibase';\nexport const toJwkPair = (\n  keypair: types.LinkedDataKeyPair\n): types.JsonWebKeyPair => {\n  // console.log('toJwkPair', keypair);\n  const id = keypair.id.substring(keypair.id.indexOf('#') + 1);\n  let _keypair: any = {\n    id: keypair.id,\n    type: 'JsonWebKey2020',\n    controller: keypair.controller,\n  };\n\n  _keypair.publicKeyJwk = {\n    ...getJwkTypeFromMultibase(id),\n    ...base58KeyPairToJwk({\n      publicKeyBase58: keypair.publicKeyBase58,\n    } as any),\n  };\n\n  if (keypair.privateKeyBase58) {\n    _keypair.privateKeyJwk = {\n      ...getJwkTypeFromMultibase(id),\n      ...base58KeyPairToJwk({\n        publicKeyBase58: keypair.publicKeyBase58,\n        privateKeyBase58: keypair.privateKeyBase58,\n      } as any),\n    };\n  }\n\n  return _keypair;\n};\n","import bs58 from 'bs58';\nimport base64url from 'base64url';\n\nimport { generate } from './functions/generate';\nimport { fromJwk } from './functions/fromJwk';\n\nimport { deriveSecret } from './Jwe';\nimport { privateKeyToSigner, publicKeyToVerifier } from './Jws';\nimport { toJwkPair } from './functions/toJwkPair';\nimport { fingerprintToDid } from './functions/fingerprintToDid';\nimport { getJwkTypeFromMultibase } from './functions/getJwkTypeFromMultibase';\n\nimport {\n  types,\n  getEpkGenerator,\n  deriveKey,\n  KeyEncryptionKey,\n} from '@transmute/did-key-cipher';\n\n/* class decorator */\nfunction staticImplements<T>() {\n  return <U extends T>(constructor: U) => {\n    return constructor;\n  };\n}\n\nconst KEY_TYPE = 'JsonWebKey2020';\n\n@staticImplements<types.KeyAgreementKeyPairClass>()\nexport class KeyPair implements types.KeyAgreementKeyPairInstance {\n  public static JWE_ALG: types.ECDH_ES_A256KW = 'ECDH-ES+A256KW';\n\n  static generate = async (options?: any) => {\n    const { privateKeyJwk } = await generate(options);\n    return new KeyPair({ ...fromJwk(privateKeyJwk) });\n  };\n\n  static from = (options?: any) => {\n    return new KeyPair({ ...options });\n  };\n\n  static fromFingerprint = async ({ fingerprint }: any) => {\n    const data = getJwkTypeFromMultibase(fingerprint);\n    if (data.kty) {\n      const publicKeyBytes = bs58.decode(fingerprint.substring(1));\n\n      const publicKeyBase58 = bs58.encode(publicKeyBytes.slice(3));\n\n      return new KeyPair({\n        id: '#' + fingerprint,\n        controller: fingerprintToDid(fingerprint),\n        type: 'JsonWebKey2020',\n        publicKeyBase58,\n      });\n    }\n    throw new Error('Cannot create key from fingerprint ' + fingerprint);\n  };\n\n  static fingerprintFromPublicKey(\n    keypair: types.KeyPairJwk | types.KeyPairBase58\n  ) {\n    let kp = KeyPair.from(keypair);\n    return kp.id.substring(1);\n  }\n\n  static async generateEphemeralKeyPair(\n    epkArgs: any\n  ): Promise<types.EpkResult> {\n    return getEpkGenerator(KeyPair, epkArgs)();\n  }\n\n  static async kekFromEphemeralPeer({\n    keyAgreementKey,\n    epk,\n  }: types.KeyEncryptionKeyFromEphemeralPublicKeyOptions) {\n    if (!(epk && typeof epk === 'object')) {\n      throw new TypeError('\"epk\" must be an object.');\n    }\n\n    // convert to LD key for Web KMS\n    const ephemeralPublicKey = new KeyPair({\n      publicKeyJwk: epk,\n    } as any);\n\n    // safe to use IDs like in rfc7518 or does\n    // https://tools.ietf.org/html/rfc7748#section-7 pose any issues?\n\n    // \"Party U Info\"\n    const producerInfo = ephemeralPublicKey.publicKeyBuffer;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(keyAgreementKey.id);\n    // converts keys again....\n    // base58 encoding should only be used at the network / serialization boundary.\n    const secret = await (keyAgreementKey as types.KeyAgreementKeyPairInstance).deriveSecret(\n      {\n        publicKey: ephemeralPublicKey.toJsonWebKey(),\n      } as any\n    );\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n    };\n  }\n\n  static async kekFromStaticPeer({\n    ephemeralKeyPair,\n    staticPublicKey,\n  }: types.KeyEncryptionKeyFromStaticPublicKeyOptions) {\n    // TODO: consider accepting JWK format for `staticPublicKey` not just LD key\n    if (staticPublicKey.type !== KEY_TYPE) {\n      throw new Error(`\"staticPublicKey.type\" must be \"${KEY_TYPE}\".`);\n    }\n\n    const epkPair = await KeyPair.from(ephemeralKeyPair.keypair);\n\n    // \"Party U Info\"\n    const producerInfo = epkPair.publicKeyBuffer;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(staticPublicKey.id);\n\n    const secret = await epkPair.deriveSecret({\n      publicKey: staticPublicKey,\n    } as any);\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n      epk: ephemeralKeyPair.epk,\n      apu: base64url.encode(producerInfo),\n      apv: base64url.encode(consumerInfo as any),\n    };\n  }\n\n  public id: string;\n  public type: string;\n  public controller: string;\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  constructor(options: any) {\n    this.id = options.id;\n    this.type = options.type || 'JsonWebKey2020';\n\n    this.controller = options.controller;\n    if (options.publicKeyBase58) {\n      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);\n    } else if (options.publicKeyJwk) {\n      const args = fromJwk(options.publicKeyJwk);\n      this.publicKeyBuffer = bs58.decode(args.publicKeyBase58);\n      this.id = args.id;\n      this.controller = args.controller;\n    } else {\n      throw new Error('publicKeyJwk or publicKeyBase58 is required.');\n    }\n\n    if (options.privateKeyBase58) {\n      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);\n    } else if (options.privateKeyJwk) {\n      const { privateKeyBase58 } = fromJwk(options.privateKeyJwk);\n      this.privateKeyBuffer = bs58.decode(privateKeyBase58);\n    }\n  }\n\n  fingerprint() {\n    const { id } = this.toJsonWebKey();\n    return id.substring(1);\n  }\n\n  toKeyPair(exportPrivateKey = false) {\n    let options: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n    if (exportPrivateKey) {\n      options.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return options;\n  }\n\n  toJsonWebKey(exportPrivateKey = false) {\n    const options = this.toKeyPair(exportPrivateKey);\n    return toJwkPair(options);\n  }\n\n  async signer() {\n    const { privateKeyJwk } = this.toJsonWebKey(true);\n    return privateKeyToSigner(privateKeyJwk);\n  }\n\n  async verifier() {\n    const { publicKeyJwk } = this.toJsonWebKey();\n    return publicKeyToVerifier(publicKeyJwk);\n  }\n\n  deriveSecret(options: types.DeriveSecretOptions) {\n    const { privateKeyJwk } = this.toJsonWebKey(true);\n    let publicKeyJwk;\n\n    if ((options.publicKey as any).publicKeyJwk) {\n      publicKeyJwk = (options.publicKey as any).publicKeyJwk;\n    } else if ((options.publicKey as any).publicKeyBase58) {\n      ({ publicKeyJwk } = toJwkPair(options.publicKey as any));\n    } else {\n      throw new Error(\n        'Cannot deriveSecret from remote... publicKeyJwk or publicKeyBase58 must be present.'\n      );\n    }\n    return deriveSecret(privateKeyJwk, publicKeyJwk);\n  }\n}\n","import crypto from '../crypto';\nimport base64url from 'base64url';\nimport canonicalize from 'canonicalize';\n\nimport { crvToJwsHashAlg } from '../constants';\n\nexport const privateKeyToSigner = async (privateKeyJwk: any) => {\n  const privateKey = await crypto.subtle.importKey(\n    'jwk',\n    privateKeyJwk,\n    {\n      name: 'ECDSA',\n      namedCurve: privateKeyJwk.crv,\n    },\n    true,\n    ['sign']\n  );\n\n  return {\n    sign: async (data: Buffer) => {\n      const signature = await crypto.subtle.sign(\n        {\n          name: 'ECDSA',\n          hash: { name: crvToJwsHashAlg[privateKeyJwk.crv] },\n        },\n        privateKey,\n        data\n      );\n      return signature as Buffer;\n    },\n  };\n};\n\nexport const publicKeyToVerifier = async (publicKeyJwk: any) => {\n  const publicKey = await crypto.subtle.importKey(\n    'jwk',\n    publicKeyJwk,\n    {\n      name: 'ECDSA',\n      namedCurve: publicKeyJwk.crv,\n    },\n    true,\n    ['verify']\n  );\n\n  return {\n    verify: async (toBeVerified: Buffer, signature: Buffer) => {\n      const verified = await crypto.subtle.verify(\n        {\n          name: 'ECDSA',\n          hash: { name: crvToJwsHashAlg[publicKeyJwk.crv] },\n        },\n        publicKey,\n        signature,\n        toBeVerified\n      );\n      return verified;\n    },\n  };\n};\n\nexport const createJws = async (signer: any, payload: any, header: object) => {\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const encodedPayload = base64url.encode(canonicalize(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await signer.sign(Buffer.from(toBeSigned));\n  return `${toBeSigned}.${base64url.encode(Buffer.from(signature))}`;\n};\n\nexport const verifyJws = async (verifier: any, jws: string) => {\n  const [header, payload, signature] = jws.split('.');\n  const toBeVerified = `${header}.${payload}`;\n  const verified = await verifier.verify(\n    Buffer.from(toBeVerified),\n    base64url.toBuffer(signature)\n  );\n\n  return verified;\n};\n\nexport const createDetachedJws = async (\n  signer: any,\n  payload: Buffer,\n  header: object\n) => {\n  const encodedHeader = base64url.encode(\n    canonicalize({ ...header, b64: false, crit: ['b64'] })\n  );\n\n  const toBeSigned = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const signature = await signer.sign(Buffer.from(toBeSigned));\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\nexport const verifyDetachedJws = async (\n  verifier: any,\n  payload: Buffer,\n  signature: string\n) => {\n  const [encodedHeader, encodedSignature] = signature.split('..');\n\n  const toBeVerified = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n\n  const verified = await verifier.verify(\n    Buffer.from(toBeVerified),\n    base64url.toBuffer(encodedSignature)\n  );\n\n  return verified;\n};\n","import crypto from '../crypto';\n\nexport const deriveSecret = async (\n  privateKeyJwk: any,\n  publicKeyJwk: any\n): Promise<Uint8Array> => {\n  // console.log(privateKeyJwk, publicKeyJwk);\n  const privateKey = await crypto.subtle.importKey(\n    'jwk',\n    privateKeyJwk,\n    {\n      name: 'ECDH',\n      namedCurve: privateKeyJwk.crv,\n    },\n    true,\n    ['deriveBits']\n  );\n  const publicKey = await crypto.subtle.importKey(\n    'jwk',\n    publicKeyJwk,\n    {\n      name: 'ECDH',\n      namedCurve: publicKeyJwk.crv,\n    },\n    true,\n    ['deriveBits']\n  );\n  const result = await crypto.subtle.deriveBits(\n    {\n      name: 'ECDH',\n      public: publicKey,\n    },\n    privateKey,\n    256\n  );\n  return new Uint8Array(result);\n};\n","import { SUPPORTED_EC } from '../constants';\nimport crypto from '../crypto';\n\nexport interface GenerateOptions {\n  kty: string;\n  crvOrSize: string;\n}\n\nexport const generate = async (\n  options: GenerateOptions = { kty: 'EC', crvOrSize: 'P-256' }\n) => {\n  if (options.kty === 'EC' && SUPPORTED_EC.indexOf(options.crvOrSize) !== -1) {\n    let kp = await crypto.subtle.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: options.crvOrSize,\n      },\n      true,\n      ['sign', 'verify']\n    );\n    const jwk = await crypto.subtle.exportKey('jwk', kp.privateKey);\n    return {\n      publicKeyJwk: {\n        kty: jwk.kty,\n        crv: jwk.crv,\n        x: jwk.x,\n        y: jwk.y,\n      },\n      privateKeyJwk: {\n        kty: jwk.kty,\n        crv: jwk.crv,\n        x: jwk.x,\n        y: jwk.y,\n        d: jwk.d,\n      },\n    };\n  }\n\n  throw new Error(\n    `Generate does not support ${options.kty} and ${options.crvOrSize}`\n  );\n};\n","import keyto from '@trust/keyto';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\nimport bs58 from 'bs58';\nimport secp256k1 from 'secp256k1';\n\nimport canonicalize from 'canonicalize';\n\nconst compressedHexEncodedPublicKeyLength = 66;\n\n/** Secp256k1 Private Key  */\nexport interface ISecp256k1PrivateKeyJwk {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** private point */\n  d: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/** Secp256k1 Public Key  */\nexport interface ISecp256k1PublicKeyJwk {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/**\n * Example\n * ```js\n * {\n *  kty: 'EC',\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'\n * }\n * ```\n * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on Jwk.\n */\nexport const getKid = (\n  jwk: ISecp256k1PrivateKeyJwk | ISecp256k1PublicKeyJwk\n) => {\n  const copy = { ...jwk } as any;\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  const digest = crypto\n    .createHash('sha256')\n    .update(canonicalize(copy))\n    .digest();\n\n  return base64url.encode(Buffer.from(digest));\n};\n\n/** convert compressed hex encoded private key to jwk */\nexport const privateKeyJwkFromPrivateKeyHex = async (privateKeyHex: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyHex, 'blk').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert compressed hex encoded public key to jwk */\nexport const publicKeyJwkFromPublicKeyHex = async (publicKeyHex: string) => {\n  let key = publicKeyHex;\n  if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {\n    const keyBin = secp256k1.publicKeyConvert(\n      Buffer.from(publicKeyHex, 'hex'),\n      false\n    );\n    key = Buffer.from(keyBin).toString('hex');\n  }\n  const jwk = {\n    ...keyto.from(key, 'blk').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded private key to jwk */\nexport const privateKeyJwkFromPrivateKeyPem = (privateKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyPem, 'pem').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  // console.log(jwk);\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded public key to jwk */\nexport const publicKeyJwkFromPublicKeyPem = (publicKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(publicKeyPem, 'pem').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert jwk to hex encoded private key */\nexport const privateKeyHexFromJwk = async (jwk: ISecp256k1PrivateKeyJwk) =>\n  keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'private');\n\n/** convert jwk to hex encoded public key */\nexport const publicKeyHexFromJwk = async (jwk: ISecp256k1PublicKeyJwk) => {\n  const uncompressedPublicKey = keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'public');\n\n  const compressed = secp256k1.publicKeyConvert(\n    Buffer.from(uncompressedPublicKey, 'hex'),\n    true\n  );\n  return Buffer.from(compressed).toString('hex');\n};\n\n/** convert jwk to binary encoded private key */\nexport const privateKeyUInt8ArrayFromJwk = async (\n  jwk: ISecp256k1PrivateKeyJwk\n) => {\n  const privateKeyHex = await privateKeyHexFromJwk(jwk);\n  return Buffer.from(privateKeyHex, 'hex');\n};\n\n/** convert jwk to binary encoded public key */\nexport const publicKeyUInt8ArrayFromJwk = async (\n  jwk: ISecp256k1PublicKeyJwk\n) => {\n  const publicKeyHex = await publicKeyHexFromJwk(jwk);\n  return Buffer.from(publicKeyHex, 'hex');\n};\n\n/** convert publicKeyHex to base58 */\nexport const publicKeyBase58FromPublicKeyHex = (publicKeyHex: string) => {\n  return bs58.encode(Buffer.from(publicKeyHex, 'hex'));\n};\n\n/** convert publicKeyHex to base58 */\nexport const privateKeyBase58FromPrivateKeyHex = (privateKeyHex: string) => {\n  return bs58.encode(Buffer.from(privateKeyHex, 'hex'));\n};\n\nexport const privateKeyUInt8ArrayFromPrivateKeyBase58 = async (\n  privateKeyBase58: string\n) => {\n  return bs58.decode(privateKeyBase58);\n};\n\nexport const publicKeyUInt8ArrayFromPublicKeyBase58 = async (\n  publicKeyBase58: string\n) => {\n  return bs58.decode(publicKeyBase58);\n};\n\nexport const publicKeyHexFromPrivateKeyHex = async (privateKeyHex: string) => {\n  const publicKey = secp256k1.publicKeyCreate(\n    new Uint8Array(Buffer.from(privateKeyHex, 'hex'))\n  );\n  return Buffer.from(publicKey).toString('hex');\n};\n","import bs58 from 'bs58';\n\nimport {\n  convertPublicKeyToX25519,\n  convertSecretKeyToX25519,\n} from '@stablelib/ed25519';\nimport * as x25519 from '@stablelib/x25519';\nimport * as keyUtils from './keyUtils';\n\nimport base64url from 'base64url';\nimport crypto from 'crypto';\n\nimport {\n  types,\n  deriveKey,\n  getEpkGenerator,\n  KeyEncryptionKey,\n} from '@transmute/did-key-cipher';\n\nconst KEY_TYPE = 'X25519KeyAgreementKey2019';\n\n/* class decorator */\nfunction staticImplements<T>() {\n  return <U extends T>(constructor: U) => {\n    return constructor;\n  };\n}\n\n@staticImplements<types.KeyAgreementKeyPairClass>()\nexport class X25519KeyPair implements types.KeyPairInstance {\n  public id: string;\n  public type: string;\n  public controller: string;\n\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  public static JWE_ALG: types.ECDH_ES_A256KW = 'ECDH-ES+A256KW';\n\n  static fingerprintFromPublicKey(\n    keypair: types.KeyPairJwk | types.KeyPairBase58\n  ) {\n    let pubkeyBytes: any;\n\n    if ((keypair as any).publicKeyBase58) {\n      pubkeyBytes = bs58.decode(\n        (keypair as types.KeyPairBase58).publicKeyBase58\n      );\n    }\n\n    if ((keypair as any).publicKeyJwk) {\n      pubkeyBytes = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(\n          (keypair as types.KeyPairJwk).publicKeyJwk\n        )\n      );\n    }\n\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80\n\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    buffer[0] = 0xec;\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n\n  static async generate(options: types.KeyPairGenerateOptions) {\n    let key;\n\n    key = x25519.generateKeyPair({\n      isAvailable: true,\n      randomBytes: options.secureRandom,\n    });\n\n    if (!key) {\n      throw new Error('options.seed or options.secureRandom is required.');\n    }\n\n    const publicKeyBase58 = bs58.encode(key.publicKey);\n    const privateKeyBase58 = bs58.encode(key.secretKey);\n\n    const did = `did:key:${X25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    const keyId = `#${X25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    return new X25519KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    } as types.KeyPairBase58);\n  }\n\n  static async generateEphemeralKeyPair(): Promise<types.EpkResult> {\n    return getEpkGenerator(X25519KeyPair, {\n      secureRandom: () => {\n        return crypto.randomBytes(32);\n      },\n    })();\n  }\n\n  static async kekFromEphemeralPeer({\n    keyAgreementKey,\n    epk,\n  }: types.KeyEncryptionKeyFromEphemeralPublicKeyOptions) {\n    if (!(epk && typeof epk === 'object')) {\n      throw new TypeError('\"epk\" must be an object.');\n    }\n\n    // decode public key material\n    const publicKey = base64url.toBuffer(epk.x);\n\n    // convert to LD key for Web KMS\n    const ephemeralPublicKey = {\n      type: KEY_TYPE,\n      publicKeyBase58: bs58.encode(publicKey),\n    };\n\n    // safe to use IDs like in rfc7518 or does\n    // https://tools.ietf.org/html/rfc7748#section-7 pose any issues?\n\n    // \"Party U Info\"\n    const producerInfo = publicKey;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(keyAgreementKey.id);\n    // converts keys again....\n    // base58 encoding should only be used at the network / serialization boundary.\n    const secret = await (keyAgreementKey as types.KeyAgreementKeyPairInstance).deriveSecret(\n      {\n        publicKey: ephemeralPublicKey,\n      } as any\n    );\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n    };\n  }\n\n  static async kekFromStaticPeer({\n    ephemeralKeyPair,\n    staticPublicKey,\n  }: types.KeyEncryptionKeyFromStaticPublicKeyOptions) {\n    // TODO: consider accepting JWK format for `staticPublicKey` not just LD key\n    if (\n      !(\n        staticPublicKey.type === 'X25519KeyAgreementKey2019' ||\n        staticPublicKey.type === 'JsonWebKey2020'\n      )\n    ) {\n      throw new Error(\n        `\"staticPublicKey.type\" must be \"X25519KeyAgreementKey2019\".`\n      );\n    }\n\n    const epkPair = await X25519KeyPair.from(ephemeralKeyPair.keypair);\n\n    // \"Party U Info\"\n    const producerInfo = epkPair.publicKeyBuffer;\n    // \"Party V Info\"\n    const consumerInfo = Buffer.from(staticPublicKey.id);\n\n    const secret = await epkPair.deriveSecret({\n      publicKey: staticPublicKey,\n    } as any);\n    const keyData = await deriveKey({ secret, producerInfo, consumerInfo });\n    return {\n      kek: await KeyEncryptionKey.createKek({ keyData }),\n      epk: ephemeralKeyPair.epk,\n      apu: base64url.encode(producerInfo),\n      apv: base64url.encode(consumerInfo as any),\n    };\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80\n    if (buffer[0] === 0xec && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${X25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      const keyId = `#${X25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      return new X25519KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      } as types.KeyPairBase58);\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n\n  static fromEdKeyPair(ed25519KeyPair: types.KeyPairBase58) {\n    let publicKeyBase58;\n    let privateKeyBase58;\n\n    if (ed25519KeyPair.publicKeyBase58) {\n      publicKeyBase58 = bs58.encode(\n        convertPublicKeyToX25519(bs58.decode(ed25519KeyPair.publicKeyBase58))\n      );\n    }\n\n    if (ed25519KeyPair.privateKeyBase58) {\n      privateKeyBase58 = bs58.encode(\n        convertSecretKeyToX25519(bs58.decode(ed25519KeyPair.privateKeyBase58))\n      );\n    }\n\n    return new X25519KeyPair({\n      controller: ed25519KeyPair.controller,\n      publicKeyBase58,\n      privateKeyBase58,\n    } as types.KeyPairBase58);\n  }\n\n  static from(options: types.KeyPairBase58 | types.KeyPairJwk) {\n    let privateKeyBase58;\n    let publicKeyBase58;\n\n    if ((options as types.KeyPairBase58).publicKeyBase58) {\n      publicKeyBase58 = (options as types.KeyPairBase58).publicKeyBase58;\n    }\n\n    if ((options as types.KeyPairBase58).privateKeyBase58) {\n      privateKeyBase58 = (options as types.KeyPairBase58).privateKeyBase58;\n    }\n\n    if ((options as types.KeyPairJwk).privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyJwk(\n        (options as types.KeyPairJwk).privateKeyJwk\n      );\n    }\n\n    if ((options as types.KeyPairJwk).publicKeyJwk) {\n      publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyJwk(\n        (options as types.KeyPairJwk).publicKeyJwk\n      );\n    }\n\n    return new X25519KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  constructor(options: types.KeyPairJwk | types.KeyPairBase58) {\n    this.type = 'X25519KeyAgreementKey2019';\n    this.id = options.id;\n    this.controller = options.controller;\n\n    if ((options as types.KeyPairBase58).publicKeyBase58) {\n      this.publicKeyBuffer = Buffer.from(\n        bs58.decode((options as types.KeyPairBase58).publicKeyBase58)\n      );\n    } else if ((options as types.JsonWebKeyPair).publicKeyJwk) {\n      this.publicKeyBuffer = Buffer.from(\n        bs58.decode(\n          keyUtils.publicKeyBase58FromPublicKeyJwk(\n            (options as types.JsonWebKeyPair).publicKeyJwk\n          )\n        )\n      );\n    } else {\n      throw new Error(\n        'publicKeyBase58 or publicKeyJwk is required in the options.'\n      );\n    }\n\n    if ((options as types.KeyPairBase58).privateKeyBase58) {\n      this.privateKeyBuffer = Buffer.from(\n        bs58.decode((options as types.KeyPairBase58).privateKeyBase58)\n      );\n    }\n\n    if ((options as types.JsonWebKeyPair).privateKeyJwk) {\n      this.privateKeyBuffer = Buffer.from(\n        bs58.decode(\n          keyUtils.privateKeyBase58FromPrivateKeyJwk(\n            (options as types.JsonWebKeyPair).privateKeyJwk\n          )\n        )\n      );\n    }\n\n    if (!this.id) {\n      this.id = `#${this.fingerprint()}`;\n    }\n  }\n\n  fingerprint() {\n    return X25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    } as any);\n  }\n\n  verifyFingerprint(fingerprint: any) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n    let publicKeyBuffer = this.publicKeyBuffer;\n\n    // validate the first two multicodec bytes 0xec01\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L80\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'ec01' &&\n      publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  toKeyPair(_private: boolean = false): types.LinkedDataKeyPair {\n    let kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n    if (_private) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return kp;\n  }\n\n  toJsonWebKey(_private: boolean = false): types.JsonWebKeyPair {\n    let kp: any = {\n      id: this.id,\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: this.toJwk(),\n    };\n    delete kp.publicKeyJwk.kid;\n    if (_private) {\n      kp.privateKeyJwk = this.toJwk(true);\n      delete kp.privateKeyJwk.kid;\n    }\n\n    return kp;\n  }\n\n  toJwk(_private: boolean = false) {\n    const publicKeyBase58 = bs58.encode(this.publicKeyBuffer);\n    if (_private) {\n      return keyUtils.privateKeyJwkFromPrivateKeyBase58(\n        publicKeyBase58,\n        bs58.encode(this.privateKeyBuffer)\n      );\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyBase58(publicKeyBase58);\n  }\n\n  deriveSecret(options: types.DeriveSecretOptions) {\n    let remotePubkeyBytes;\n\n    const { publicKey } = options;\n\n    if ((publicKey as any).publicKeyBase58) {\n      remotePubkeyBytes = bs58.decode(\n        (publicKey as types.LinkedDataKeyPair).publicKeyBase58\n      );\n    } else if ((publicKey as any).publicKeyJwk) {\n      remotePubkeyBytes = bs58.decode(\n        keyUtils.publicKeyBase58FromPublicKeyJwk(\n          (publicKey as types.JsonWebKeyPair).publicKeyJwk\n        )\n      );\n    }\n\n    const privateKeyBytes = this.privateKeyBuffer as Buffer;\n\n    const scalarMultipleResult = x25519.sharedKey(\n      new Uint8Array(privateKeyBytes),\n      new Uint8Array(remotePubkeyBytes),\n      true\n    );\n\n    return scalarMultipleResult;\n  }\n}\n","\n'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./did-key-bls12381.cjs.production.min.js')\n} else {\n  module.exports = require('./did-key-bls12381.cjs.development.js')\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 546;","import base64url from 'base64url';\n\nimport * as ed25519 from '@stablelib/ed25519';\n\nimport canonicalize from 'canonicalize';\n\nclass JWSVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWSVerificationFailed';\n  }\n}\n\nconst _jwkToSecretKey = (jwk: any) => {\n  const d = base64url.toBuffer(jwk.d);\n  const x = base64url.toBuffer(jwk.x);\n  const secretKey = new Uint8Array(Buffer.concat([d, x]));\n  return secretKey;\n};\n\nconst _jwkToPublicKey = (jwk: any) => {\n  const x = base64url.toBuffer(jwk.x);\n  const publicKey = new Uint8Array(x);\n  return publicKey;\n};\n\nexport const decode = (jws: string, options = { complete: false }) => {\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature,\n    };\n  }\n  return JSON.parse(base64url.decode(encodedPayload));\n};\n\nexport const sign = (\n  payload: any,\n  privateKeyJwk: any,\n  header: any = {\n    alg: 'EdDSA',\n  }\n) => {\n  const secretKey = _jwkToSecretKey(privateKeyJwk);\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const encodedPayload = base64url.encode(canonicalize(payload));\n  const message = new Uint8Array(\n    Buffer.from(`${encodedHeader}.${encodedPayload}`)\n  );\n  const signature = ed25519.sign(secretKey, message);\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  const jws = `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n  return jws;\n};\n\nexport const signDetached = (\n  payload: Buffer,\n  privateKeyJwk: any,\n  header: any = {\n    alg: 'EdDSA',\n  }\n) => {\n  const secretKey = _jwkToSecretKey(privateKeyJwk);\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const message = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const signature = ed25519.sign(secretKey, message);\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  const jws = `${encodedHeader}..${encodedSignature}`;\n  return jws;\n};\n\nexport const verify = (jws: string, publicKeyJwk: any) => {\n  const publicKey = _jwkToPublicKey(publicKeyJwk);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  const message = new Uint8Array(\n    Buffer.from(`${encodedHeader}.${encodedPayload}`)\n  );\n  const verified = ed25519.verify(\n    publicKey,\n    message,\n    new Uint8Array(base64url.toBuffer(encodedSignature))\n  );\n\n  if (verified) {\n    return JSON.parse(base64url.decode(encodedPayload));\n  }\n\n  throw new JWSVerificationFailed('signature verification failed');\n};\n\nexport const verifyDetached = (\n  jws: string,\n  payload: Buffer,\n  publicKeyJwk: any\n) => {\n  const publicKey = _jwkToPublicKey(publicKeyJwk);\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const message = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const verified = ed25519.verify(\n    publicKey,\n    message,\n    new Uint8Array(base64url.toBuffer(encodedSignature))\n  );\n  return verified;\n};\n\nexport default {\n  decode,\n\n  sign,\n  signDetached,\n\n  verify,\n  verifyDetached,\n};\n","import bs58 from 'bs58';\n\nimport * as ed25519 from '@stablelib/ed25519';\nimport * as keyUtils from './keyUtils';\n\nimport { X25519KeyPair } from '@transmute/did-key-x25519';\n\nexport class Ed25519KeyPair {\n  public id: string;\n  public type: string;\n  public controller: string;\n  public publicKeyBase58: string;\n  public privateKeyBase58: string;\n\n  static fingerprintFromPublicKey({ publicKeyBase58 }: any) {\n    // ed25519 cryptonyms are multicodec encoded values, specifically:\n    // (multicodec ed25519-pub 0xed01 + key bytes)\n    const pubkeyBytes = bs58.decode(publicKeyBase58);\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    buffer[0] = 0xed;\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n  static async generate(options: any = {}) {\n    let key;\n    if (options.secureRandom) {\n      key = ed25519.generateKeyPair({\n        isAvailable: true,\n        randomBytes: options.secureRandom,\n      });\n    }\n\n    if (options.seed) {\n      key = ed25519.generateKeyPair({\n        isAvailable: true,\n        randomBytes: () => {\n          return Buffer.from(options.seed, 'hex');\n        },\n      });\n    }\n\n    if (!key) {\n      throw new Error('options.seed or options.secureRandom is required.');\n    }\n\n    const publicKeyBase58 = bs58.encode(key.publicKey);\n    const privateKeyBase58 = bs58.encode(key.secretKey);\n\n    const did = `did:key:${Ed25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    })}`;\n    const keyId = `#${Ed25519KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    })}`;\n    return new Ed25519KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    });\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L81\n    if (buffer[0] === 0xed && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${Ed25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      })}`;\n      const keyId = `#${Ed25519KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      })}`;\n      return new Ed25519KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n  static async from(options: any) {\n    let privateKeyBase58 = options.privateKeyBase58;\n    let publicKeyBase58 = options.publicKeyBase58;\n\n    if (options.privateKeyHex) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n        options.privateKeyHex\n      );\n    }\n\n    if (options.publicKeyHex) {\n      publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyHex(\n        options.publicKeyHex\n      );\n    }\n\n    if (options.privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyJwk(\n        options.privateKeyJwk\n      );\n    }\n\n    if (options.publicKeyJwk) {\n      publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyJwk(\n        options.publicKeyJwk\n      );\n    }\n\n    return new Ed25519KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  constructor(options: any = {}) {\n    this.type = 'Ed25519VerificationKey2018';\n    this.id = options.id;\n    this.controller = options.controller;\n    this.publicKeyBase58 = options.publicKeyBase58;\n    this.privateKeyBase58 = options.privateKeyBase58;\n    if (this.controller && !this.id) {\n      this.id = `${this.controller}#${this.fingerprint()}`;\n    }\n  }\n\n  get publicKey() {\n    return this.publicKeyBase58;\n  }\n\n  get privateKey() {\n    return this.privateKeyBase58;\n  }\n  addEncodedPublicKey(publicKeyNode: any) {\n    publicKeyNode.publicKeyBase58 = this.publicKeyBase58;\n    return publicKeyNode;\n  }\n\n  public publicNode({ controller = this.controller }: any = {}) {\n    const publicNode: any = {\n      id: this.id,\n      type: this.type,\n    };\n    if (controller) {\n      publicNode.controller = controller;\n    }\n\n    this.addEncodedPublicKey(publicNode); // Subclass-specific\n    return publicNode;\n  }\n\n  fingerprint() {\n    const { publicKeyBase58 } = this;\n    return Ed25519KeyPair.fingerprintFromPublicKey({ publicKeyBase58 });\n  }\n  verifyFingerprint(fingerprint: any) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n    let publicKeyBuffer;\n    try {\n      publicKeyBuffer = bs58.decode(this.publicKeyBase58);\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n\n    // validate the first two multicodec bytes 0xed01\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'ed01' &&\n      publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  async toJwk(_private: boolean = false) {\n    if (_private) {\n      return keyUtils.privateKeyJwkFromPrivateKeyBase58(this.privateKeyBase58);\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyBase58(this.publicKeyBase58);\n  }\n\n  async toHex(_private: boolean = false) {\n    if (_private) {\n      return keyUtils.privateKeyHexFromPrivateKeyBase58(this.privateKeyBase58);\n    }\n    return keyUtils.publicKeyHexFromPublicKeyBase58(this.publicKeyBase58);\n  }\n\n  toX25519KeyPair(_private: boolean = false) {\n    const x25519 = X25519KeyPair.fromEdKeyPair({\n      controller: this.controller,\n      publicKeyBase58: this.publicKeyBase58,\n      privateKeyBase58: this.privateKeyBase58,\n    } as any);\n    if (!_private) {\n      delete x25519.privateKeyBuffer;\n    }\n    return x25519;\n  }\n\n  toKeyPair(_private: boolean = false) {\n    const kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: this.publicKeyBase58,\n    };\n\n    if (!_private) {\n      kp.privateKeyBase58 = this.privateKeyBase58;\n    }\n    return kp;\n  }\n\n  signer() {\n    if (!this.privateKeyBase58) {\n      return {\n        async sign() {\n          throw new Error('No private key to sign with.');\n        },\n      };\n    }\n    let privateKeyBase58 = this.privateKeyBase58;\n    return {\n      async sign({ data }: any) {\n        const signatureUInt8Array = ed25519.sign(\n          bs58.decode(privateKeyBase58),\n          data\n        );\n        return signatureUInt8Array;\n      },\n    };\n  }\n  verifier() {\n    if (!this.publicKeyBase58) {\n      return {\n        async sign() {\n          throw new Error('No public key to verify with.');\n        },\n      };\n    }\n    let publicKeyBase58 = this.publicKeyBase58;\n    return {\n      async verify({ data, signature }: any) {\n        let verified = false;\n        try {\n          verified = ed25519.verify(\n            bs58.decode(publicKeyBase58),\n            data,\n            signature\n          );\n        } catch (e) {\n          console.error('An error occurred when verifying signature: ', e);\n        }\n        return verified;\n      },\n    };\n  }\n}\n","import crypto from 'crypto';\n\nimport * as keyUtils from './keyUtils';\nimport bs58 from 'bs58';\nimport secp256k1 from 'secp256k1';\n\nconst _generate = (secureRandom: any) => {\n  let privateKey;\n  do {\n    privateKey = secureRandom();\n  } while (!secp256k1.privateKeyVerify(privateKey));\n\n  const publicKey = secp256k1.publicKeyCreate(privateKey);\n  return { publicKey, privateKey };\n};\n\nexport class Secp256k1KeyPair {\n  public id: string;\n  public type: string;\n  public controller: string;\n\n  public publicKeyBase58: string;\n  public privateKeyBase58: string;\n\n  static fingerprintFromPublicKey({ publicKeyBase58 }: any) {\n    const pubkeyBytes = bs58.decode(publicKeyBase58);\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    // See https://github.com/multiformats/multicodec/blob/master/table.csv\n    // 0xe7 is Secp256k1 public key\n    buffer[0] = 0xe7; //\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n\n  static async generate(options: any = {}) {\n    let privateKey;\n    let publicKey;\n    if (options.secureRandom) {\n      ({ privateKey, publicKey } = _generate(options.secureRandom));\n    }\n    if (options.seed) {\n      ({ privateKey, publicKey } = _generate(() => {\n        return new Uint8Array(options.seed);\n      }));\n    }\n    if (!privateKey) {\n      throw new Error('Cannot generate private key.');\n    }\n\n    const publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyHex(\n      Buffer.from(publicKey).toString('hex')\n    );\n    const privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n      Buffer.from(privateKey).toString('hex')\n    );\n\n    const did = `did:key:${Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    })}`;\n    const keyId = `#${Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    })}`;\n\n    return new Secp256k1KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    });\n  }\n\n  static async from(options: any) {\n    let privateKeyBase58 = options.privateKeyBase58;\n    let publicKeyBase58 = options.publicKeyBase58;\n\n    if (options.privateKeyHex) {\n      privateKeyBase58 = await keyUtils.privateKeyBase58FromPrivateKeyHex(\n        options.privateKeyHex\n      );\n    }\n\n    if (options.publicKeyHex) {\n      publicKeyBase58 = await keyUtils.publicKeyBase58FromPublicKeyHex(\n        options.publicKeyHex\n      );\n    }\n\n    if (options.privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n        await keyUtils.privateKeyHexFromJwk(options.privateKeyJwk)\n      );\n    }\n\n    if (options.publicKeyJwk) {\n      publicKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n        await keyUtils.publicKeyHexFromJwk(options.publicKeyJwk)\n      );\n    }\n\n    return new Secp256k1KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L77\n    if (buffer[0] === 0xe7 && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${Secp256k1KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      })}`;\n      const keyId = `#${Secp256k1KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      })}`;\n      return new Secp256k1KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n\n  constructor(options: any = {}) {\n    this.type = 'EcdsaSecp256k1VerificationKey2019';\n\n    this.id = options.id;\n    this.controller = options.controller;\n    this.privateKeyBase58 = options.privateKeyBase58;\n    this.publicKeyBase58 = options.publicKeyBase58;\n  }\n\n  get publicKey() {\n    return this.publicKeyBase58;\n  }\n\n  get privateKey() {\n    return this.privateKeyBase58;\n  }\n\n  signer() {\n    if (!this.privateKeyBase58) {\n      return {\n        async sign() {\n          throw new Error('No private key to sign with.');\n        },\n      };\n    }\n    let privateKeyBase58 = this.privateKeyBase58;\n    return {\n      async sign({ data }: any) {\n        const messageHashUInt8Array = crypto\n          .createHash('sha256')\n          .update(data)\n          .digest();\n        const privateKeyUInt8Array = await keyUtils.privateKeyUInt8ArrayFromPrivateKeyBase58(\n          privateKeyBase58\n        );\n        const sigObj: any = secp256k1.ecdsaSign(\n          messageHashUInt8Array,\n          privateKeyUInt8Array\n        );\n\n        return sigObj.signature;\n      },\n    };\n  }\n\n  verifier() {\n    if (!this.publicKeyBase58) {\n      return {\n        async sign() {\n          throw new Error('No public key to verify with.');\n        },\n      };\n    }\n    let publicKeyBase58 = this.publicKeyBase58;\n    return {\n      async verify({ data, signature }: any) {\n        const messageHashUInt8Array = crypto\n          .createHash('sha256')\n          .update(data)\n          .digest();\n\n        const publicKeyUInt8Array = await keyUtils.publicKeyUInt8ArrayFromPublicKeyBase58(\n          publicKeyBase58\n        );\n\n        let verified = false;\n        try {\n          verified = secp256k1.ecdsaVerify(\n            signature,\n            messageHashUInt8Array,\n            publicKeyUInt8Array\n          );\n        } catch (e) {\n          console.error('An error occurred when verifying signature: ', e);\n        }\n        return verified;\n      },\n    };\n  }\n\n  addEncodedPublicKey(publicKeyNode: any) {\n    publicKeyNode.publicKeyBase58 = this.publicKeyBase58;\n    return publicKeyNode;\n  }\n\n  fingerprint() {\n    const { publicKeyBase58 } = this;\n    return Secp256k1KeyPair.fingerprintFromPublicKey({ publicKeyBase58 });\n  }\n\n  verifyFingerprint(fingerprint: string) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n    let publicKeyBuffer;\n    try {\n      publicKeyBuffer = bs58.decode(this.publicKeyBase58);\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n\n    // validate the first two multicodec bytes 0xe701\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'e701' &&\n      publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  publicNode({ controller = this.controller } = {}) {\n    const publicNode: any = {\n      id: this.id,\n      type: this.type,\n    };\n    if (controller) {\n      publicNode.controller = controller;\n    }\n    this.addEncodedPublicKey(publicNode); // Subclass-specific\n    return publicNode;\n  }\n\n  async toJwk(_private: boolean = false) {\n    if (_private) {\n      return keyUtils.privateKeyJwkFromPrivateKeyHex(\n        bs58.decode(this.privateKeyBase58).toString('hex')\n      );\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyHex(\n      bs58.decode(this.publicKeyBase58).toString('hex')\n    );\n  }\n\n  async toHex(_private: boolean = false) {\n    if (_private) {\n      return keyUtils.privateKeyHexFromJwk(\n        await keyUtils.privateKeyJwkFromPrivateKeyHex(\n          bs58.decode(this.privateKeyBase58).toString('hex')\n        )\n      );\n    }\n    return keyUtils.publicKeyHexFromJwk(\n      await keyUtils.publicKeyJwkFromPublicKeyHex(\n        bs58.decode(this.publicKeyBase58).toString('hex')\n      )\n    );\n  }\n\n  toKeyPair(exportPrivate = false) {\n    const kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: this.publicKeyBase58,\n    };\n    if (exportPrivate) {\n      kp.privateKeyBase58 = this.privateKeyBase58;\n    }\n    return kp;\n  }\n}\n","import base64url from 'base64url';\n\nimport crypto from 'crypto';\nimport secp256k1 from 'secp256k1';\n\nimport {\n  ISecp256k1PrivateKeyJwk,\n  ISecp256k1PublicKeyJwk,\n  privateKeyUInt8ArrayFromJwk,\n  publicKeyUInt8ArrayFromJwk,\n} from './keyUtils';\n\n/** error matching @panva/jose for JWS verification failure. */\nclass JWSVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWSVerificationFailed';\n  }\n}\n\n/** JWS Header */\nexport interface IJWSHeader {\n  /** algorithm, ES256K */\n  alg: string;\n\n  /** type, JWT */\n  typ?: string;\n  /** signing key id, ... */\n  kid?: string;\n}\n\n/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const signDetached = async (\n  // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData\n  payload: Buffer,\n  privateKeyJwk: ISecp256k1PrivateKeyJwk,\n  header = {\n    alg: 'ES256K',\n    b64: false,\n    crit: ['b64'],\n  }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n\n  const message = Buffer.from(toBeSignedBuffer);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const sigObj: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const encodedSignature = base64url.encode(Buffer.from(sigObj.signature));\n\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\n/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const verifyDetached = async (\n  jws: string,\n  payload: Buffer,\n  publicKeyJwk: ISecp256k1PublicKeyJwk\n) => {\n  if (jws.indexOf('..') === -1) {\n    throw new JWSVerificationFailed('not a valid rfc7797 jws.');\n  }\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const header = JSON.parse(base64url.decode(encodedHeader));\n  if (header.alg !== 'ES256K') {\n    throw new Error('JWS alg is not signed with ES256K.');\n  }\n  if (\n    header.b64 !== false ||\n    !header.crit ||\n    !header.crit.length ||\n    header.crit[0] !== 'b64'\n  ) {\n    throw new Error('JWS Header is not in rfc7797 format (not detached).');\n  }\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJwk(publicKeyJwk);\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n  const message = Buffer.from(toBeSignedBuffer);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const signatureUInt8Array = base64url.toBuffer(encodedSignature);\n  let signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);\n  const verified = secp256k1.ecdsaVerify(\n    signatureLowerS,\n    messageHashUInt8Array,\n    publicKeyUInt8Array\n  );\n\n  if (verified) {\n    return true;\n  }\n  const erroObject = {\n    signature: signatureUInt8Array.toString('hex'),\n    // message: messageHashUInt8Array.toString('hex'),\n    // publicKey: publicKeyUInt8Array.toString('hex'),\n  };\n  throw new JWSVerificationFailed(\n    'ECDSA Verify Failed: ' + JSON.stringify(erroObject, null, 2)\n  );\n};\n\n/** Produce a normal ES256K JWS */\nexport const sign = async (\n  payload: any,\n  privateKeyJwk: ISecp256k1PrivateKeyJwk,\n  header: IJWSHeader = { alg: 'ES256K' }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  const encodedPayload = base64url.encode(JSON.stringify(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const message = Buffer.from(toBeSigned);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n\n  const sigObj: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const encodedSignature = base64url.encode(sigObj.signature);\n  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n};\n\n/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */\nexport const verify = async (\n  jws: string,\n  publicKeyJwk: ISecp256k1PublicKeyJwk\n) => {\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJwk(publicKeyJwk);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n\n  const message = Buffer.from(toBeSigned);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n\n  const signatureUInt8Array = base64url.toBuffer(encodedSignature);\n  let signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);\n\n  const verified = secp256k1.ecdsaVerify(\n    signatureLowerS,\n    messageHashUInt8Array,\n    publicKeyUInt8Array\n  );\n  if (verified) {\n    return JSON.parse(base64url.decode(encodedPayload));\n  }\n  const erroObject = {\n    signature: signatureUInt8Array.toString('hex'),\n    message: messageHashUInt8Array.toString('hex'),\n    publicKey: publicKeyUInt8Array.toString('hex'),\n  };\n  throw new JWSVerificationFailed(\n    'ECDSA Verify Failed: ' + JSON.stringify(erroObject, null, 2)\n  );\n};\n\n/** decode a JWS (without verifying it) */\nexport const decode = (jws: string, options = { complete: false }) => {\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature,\n    };\n  }\n  return JSON.parse(base64url.decode(encodedPayload));\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 760;","import { withHandlers } from \"recompose\";\nimport { EdvClient } from \"edv-client\";\nimport { UniversalWallet2020, VaultClient } from \"@transmute/universal-wallet\";\n\n// correct horse battery staple\n\nconst getClient = async (wallet) => {\n  let _wallet = new UniversalWallet2020(wallet.contents);\n  const entropy = _wallet.contents.find((c) => {\n    return c.type === \"Entropy\";\n  });\n  const ed25519Key = _wallet.contents.find((c) => {\n    return c.type === \"Ed25519VerificationKey2018\";\n  });\n  ed25519Key.controller = ed25519Key.id.split(\"#\")[0];\n  const x25519Key = _wallet.contents.find((c) => {\n    return c.type === \"X25519KeyAgreementKey2019\";\n  });\n  x25519Key.controller = x25519Key.id.split(\"#\")[0];\n  let client = await VaultClient.fromDerivedContents(\n    wallet.vaultEndpoint,\n    ed25519Key,\n    x25519Key,\n    Buffer.from(entropy.value, \"hex\")\n  );\n  return client;\n};\n\nconst isContentPersisted = (localContents, id) => {\n  return (\n    localContents.find((c) => {\n      return c.id === id;\n    }) !== undefined\n  );\n};\n\nexport default withHandlers({\n  setUniversalWalletProp: ({ setUniversalWalletProp }) => (payload) => {\n    setUniversalWalletProp(payload);\n  },\n  generateWallet: ({ setUniversalWalletProp }) => async (_seed) => {\n    if (!_seed) {\n      throw new Error(\"seed is required.\");\n    }\n    let wallet = await UniversalWallet2020.generate(_seed);\n    setUniversalWalletProp({\n      status: wallet.status,\n      contents: wallet.contents,\n    });\n  },\n  toggleLockStatus: ({ setUniversalWalletProp }) => async ({\n    status,\n    password,\n    contents,\n  }) => {\n    let wallet = new UniversalWallet2020(contents);\n    wallet.status = status;\n\n    if (status === \"LOCKED\") {\n      await wallet.unlock(password);\n    }\n    if (status === \"UNLOCKED\") {\n      await wallet.lock(password);\n    }\n    setUniversalWalletProp({\n      status: wallet.status,\n      contents: wallet.contents,\n    });\n  },\n\n  deleteWallet: ({ setUniversalWalletProp }) => async () => {\n    setUniversalWalletProp({\n      status: \"UNLOCKED\",\n      contents: [],\n    });\n  },\n\n  importWallet: ({ setUniversalWalletProp }) => async (encryptedWallet) => {\n    let wallet = new UniversalWallet2020();\n    await wallet.import(encryptedWallet);\n    setUniversalWalletProp({\n      status: wallet.status,\n      contents: wallet.contents,\n    });\n  },\n\n  exportWallet: () => async (status, contents) => {\n    if (status !== \"LOCKED\") {\n      throw new Error(\"Cannot export unlocked wallet.\");\n    }\n    let wallet = new UniversalWallet2020(contents);\n    wallet.status = status;\n    return wallet.export();\n  },\n\n  saveWallet: ({ setUniversalWalletProp }) => async (contents) => {\n    setUniversalWalletProp({\n      contents,\n    });\n  },\n  issueCredential: ({ wallet, setUniversalWalletProp }) => async ({\n    credential,\n    options,\n  }) => {\n    let _wallet = new UniversalWallet2020(wallet.contents);\n    const verifiableCredential = await _wallet.issue({\n      credential,\n      options,\n    });\n    setUniversalWalletProp({\n      contents: [verifiableCredential, ..._wallet.contents],\n    });\n  },\n  proveVerifiableCredential: ({ wallet, setUniversalWalletProp }) => async ({\n    verifiableCredential,\n    options,\n  }) => {\n    let _wallet = new UniversalWallet2020(wallet.contents);\n    const verifiablePresentation = await _wallet.prove({\n      verifiableCredential,\n      options,\n    });\n    setUniversalWalletProp({\n      contents: [verifiablePresentation, ..._wallet.contents],\n    });\n  },\n  syncVault: ({ wallet, setUniversalWalletProp }) => async () => {\n    setUniversalWalletProp({\n      isSyncing: true,\n    });\n    const client = await getClient(wallet);\n\n    let contents = [];\n    try {\n      contents = await client.getWalletContents();\n    } catch (e) {\n      console.log(e);\n      if (e.message === \"Request failed with status code 404\") {\n        // no-op we will add content that does not existt anyway..\n      }\n    }\n    // console.log('remote wallet contents: ', contents);\n\n    for (const content of wallet.contents) {\n      // console.log({ content });\n      const isPersisted = isContentPersisted(contents, content.id);\n      // console.log({ isPersisted });\n      if (!isPersisted) {\n        let data = JSON.parse(JSON.stringify(content));\n        delete data.tableData;\n        const doc = {\n          id: await EdvClient.generateId(),\n          content: {\n            schema: \"https://schema.org/UniversalWallet\",\n            data,\n          },\n        };\n        await client.addWalletContent(doc);\n        // console.log({ response });\n      }\n    }\n\n    contents = await client.getWalletContents();\n    setUniversalWalletProp({\n      isSyncing: false,\n      contents,\n    });\n  },\n});\n","module.exports = __webpack_public_path__ + \"static/media/logo.33b194d8.svg\";"],"sourceRoot":""}